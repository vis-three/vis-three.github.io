var W=Object.defineProperty;var q=(b,t,s)=>t in b?W(b,t,{enumerable:!0,configurable:!0,writable:!0,value:s}):b[t]=s;var M=(b,t,s)=>(q(b,typeof t!="symbol"?t+"":t,s),s);import{n as O,i as F,am as N,v as E,aG as V,M as Q}from"./three.237d835c.js";class G{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y,this.array[this.top++]=t.z}}class D{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y}}class v{constructor(t){this.plane=null,this.front=null,this.back=null,this.polygons=[],t&&this.build(t)}clone(){const t=new v;return t.plane=this.plane&&this.plane.clone(),t.front=this.front&&this.front.clone(),t.back=this.back&&this.back.clone(),t.polygons=this.polygons.map(s=>s.clone()),t}invert(){for(let s=0;s<this.polygons.length;s++)this.polygons[s].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();const t=this.front;this.front=this.back,this.back=t}clipPolygons(t){if(!this.plane)return t.slice();let s=new Array,o=new Array;for(let e=0;e<t.length;e++)this.plane.splitPolygon(t[e],s,o,s,o);return this.front&&(s=this.front.clipPolygons(s)),this.back?o=this.back.clipPolygons(o):o=[],s.concat(o)}clipTo(t){this.polygons=t.clipPolygons(this.polygons),this.front&&this.front.clipTo(t),this.back&&this.back.clipTo(t)}allPolygons(){let t=this.polygons.slice();return this.front&&(t=t.concat(this.front.allPolygons())),this.back&&(t=t.concat(this.back.allPolygons())),t}build(t){if(!t.length)return;this.plane||(this.plane=t[0].plane.clone());const s=[],o=[];for(let e=0;e<t.length;e++)this.plane.splitPolygon(t[e],this.polygons,this.polygons,s,o);s.length&&(this.front||(this.front=new v),this.front.build(s)),o.length&&(this.back||(this.back=new v),this.back.build(o))}}class d{constructor(t=0,s=0,o=0){this.x=t,this.y=s,this.z=o}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}clone(){return new d(this.x,this.y,this.z)}negate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}times(t){return this.x*=t,this.y*=t,this.z*=t,this}dividedBy(t){return this.x/=t,this.y/=t,this.z/=t,this}lerp(t,s){return this.add(new d().copy(t).sub(this).times(s))}unit(){return this.dividedBy(this.length())}length(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2)+Math.pow(this.z,2))}normalize(){return this.unit()}cross(t){const s=this.clone(),o=s.x,e=s.y,i=s.z,c=t.x,u=t.y,y=t.z;return this.x=e*y-i*u,this.y=i*c-o*y,this.z=o*u-e*c,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}toVector3(){return new O(this.x,this.y,this.z)}}class P{constructor(t,s){this.normal=t,this.w=s,this.normal=t,this.w=s}clone(){return new P(this.normal.clone(),this.w)}flip(){this.normal.negate(),this.w=-this.w}splitPolygon(t,s,o,e,i){let g=0;const p=[];for(let m=0;m<t.vertices.length;m++){const n=this.normal.dot(t.vertices[m].pos)-this.w,r=n<-P.EPSILON?2:n>P.EPSILON?1:0;g|=r,p.push(r)}switch(g){case 0:(this.normal.dot(t.plane.normal)>0?s:o).push(t);break;case 1:e.push(t);break;case 2:i.push(t);break;case 3:{const m=[],n=[];for(let r=0;r<t.vertices.length;r++){const a=(r+1)%t.vertices.length,f=p[r],x=p[a],w=t.vertices[r],k=t.vertices[a];if(f!=2&&m.push(w),f!=1&&n.push(f!=2?w.clone():w),(f|x)==3){const B=(this.w-this.normal.dot(w.pos))/this.normal.dot(new d().copy(k.pos).sub(w.pos)),A=w.interpolate(k,B);m.push(A),n.push(A.clone())}}m.length>=3&&e.push(new z(m,t.shared)),n.length>=3&&i.push(new z(n,t.shared));break}}}static fromPoints(t,s,o){const e=new d().copy(s).sub(t).cross(new d().copy(o).sub(t)).normalize();return new P(e.clone(),e.dot(t))}}P.EPSILON=1e-5;class z{constructor(t,s){this.vertices=t,this.shared=s,this.plane=P.fromPoints(t[0].pos,t[1].pos,t[2].pos)}clone(){return new z(this.vertices.map(t=>t.clone()),this.shared)}flip(){this.vertices.reverse().map(t=>t.flip()),this.plane.flip()}}class T{constructor(t,s,o,e){this.pos=new d().copy(t),this.normal=new d().copy(s),this.uv=new d().copy(o),this.uv.z=0,e&&(this.color=new d().copy(e))}clone(){return new T(this.pos,this.normal,this.uv,this.color)}flip(){this.normal.negate()}interpolate(t,s){return new T(this.pos.clone().lerp(t.pos,s),this.normal.clone().lerp(t.normal,s),this.uv.clone().lerp(t.uv,s),this.color&&t.color&&this.color.clone().lerp(t.color,s))}}class l{constructor(){this.polygons=new Array}static fromPolygons(t){const s=new l;return s.polygons=t,s}static fromGeometry(t,s){let o=[];const e=t.attributes.position,i=t.attributes.normal,c=t.attributes.uv,u=t.attributes.color,y=t.groups;let h;if(t.index)h=t.index.array;else{h=new Array(e.array.length/e.itemSize|0);for(let p=0;p<h.length;p++)h[p]=p}const g=h.length/3|0;o=new Array(g);for(let p=0,m=0,n=h.length;p<n;p+=3,m++){const r=new Array(3);for(let a=0;a<3;a++){const f=h[p+a],x=f*3,w=f*2,k=e.array[x],B=e.array[x+1],A=e.array[x+2],I=i.array[x],R=i.array[x+1],L=i.array[x+2],j=c==null?void 0:c.array[w],K=c==null?void 0:c.array[w+1];r[a]=new T(new d(k,B,A),new d(I,R,L),new d(j,K,0),u&&new d(u.array[w],u.array[w+1],u.array[w+2]))}if(s===void 0&&y&&y.length>0)for(const a of y)p>=a.start&&p<a.start+a.count&&(o[m]=new z(r,a.materialIndex));else o[m]=new z(r,s)}return l.fromPolygons(o.filter(p=>!isNaN(p.plane.normal.x)))}static toGeometry(t,s){let o=0;const e=t.polygons;for(const n of e)o+=n.vertices.length-2;const i=new F,c=new G(o*3*3),u=new G(o*3*3),y=new D(o*2*3);let h;const g=[],p=[];for(const n of e){const r=n.vertices,a=r.length;n.shared!==void 0&&(g[n.shared]||(g[n.shared]=[])),a&&r[0].color!==void 0&&(h||(h=new G(o*3*3)));for(let f=3;f<=a;f++)(n.shared===void 0?p:g[n.shared]).push(c.top/3,c.top/3+1,c.top/3+2),c.write(r[0].pos),c.write(r[f-2].pos),c.write(r[f-1].pos),u.write(r[0].normal),u.write(r[f-2].normal),u.write(r[f-1].normal),y&&(y.write(r[0].uv),y.write(r[f-2].uv),y.write(r[f-1].uv)),h&&(h.write(r[0].color),h.write(r[f-2].color),h.write(r[f-1].color))}i.setAttribute("position",new N(c.array,3)),i.setAttribute("normal",new N(u.array,3)),y&&i.setAttribute("uv",new N(y.array,2)),h&&i.setAttribute("color",new N(h.array,3));for(let n=0;n<g.length;n++)g[n]===void 0&&(g[n]=[]);if(g.length){let n=[],r=0;for(let a=0;a<g.length;a++)i.addGroup(r,g[a].length,a),r+=g[a].length,n=n.concat(g[a]);i.addGroup(r,p.length,g.length),n=n.concat(p),i.setIndex(n)}const m=new E().copy(s).invert();return i.applyMatrix4(m),i.computeBoundingSphere(),i.computeBoundingBox(),i}static fromMesh(t,s){const o=l.fromGeometry(t.geometry,s),e=new O,i=new V;i.getNormalMatrix(t.matrix);for(let c=0;c<o.polygons.length;c++){const u=o.polygons[c];for(let y=0;y<u.vertices.length;y++){const h=u.vertices[y];h.pos.copy(e.copy(h.pos.toVector3()).applyMatrix4(t.matrix)),h.normal.copy(e.copy(h.normal.toVector3()).applyMatrix3(i))}}return o}static toMesh(t,s,o){const e=l.toGeometry(t,s),i=new Q(e,o);return i.matrix.copy(s),i.matrix.decompose(i.position,i.quaternion,i.scale),i.rotation.setFromQuaternion(i.quaternion),i.updateMatrixWorld(),i.castShadow=i.receiveShadow=!0,i}static union(t,s){const o=l.fromMesh(t),e=l.fromMesh(s);return l.toMesh(o.union(e),t.matrix,t.material)}static subtract(t,s){const o=l.fromMesh(t),e=l.fromMesh(s);return l.toMesh(o.subtract(e),t.matrix,t.material)}static intersect(t,s){const o=l.fromMesh(t),e=l.fromMesh(s);return l.toMesh(o.intersect(e),t.matrix,t.material)}clone(){const t=new l;return t.polygons=this.polygons.map(s=>s.clone()).filter(s=>Number.isFinite(s.plane.w)),t}toPolygons(){return this.polygons}union(t){const s=new v(this.clone().polygons),o=new v(t.clone().polygons);return s.clipTo(o),o.clipTo(s),o.invert(),o.clipTo(s),o.invert(),s.build(o.allPolygons()),l.fromPolygons(s.allPolygons())}subtract(t){const s=new v(this.clone().polygons),o=new v(t.clone().polygons);return s.invert(),s.clipTo(o),o.clipTo(s),o.invert(),o.clipTo(s),o.invert(),s.build(o.allPolygons()),s.invert(),l.fromPolygons(s.allPolygons())}intersect(t){const s=new v(this.clone().polygons),o=new v(t.clone().polygons);return s.invert(),o.clipTo(s),o.invert(),s.clipTo(o),o.clipTo(s),s.build(o.allPolygons()),s.invert(),l.fromPolygons(s.allPolygons())}inverse(){const t=this.clone();for(const s of t.polygons)s.flip();return t}toMesh(t,s){return l.toMesh(this,t,s)}toGeometry(t){return l.toGeometry(this,t)}}class H{constructor(t){M(this,"visible",!0);t.visible&&(this.visible=t.visible)}}class X extends H{constructor(s){super(s);M(this,"_source");M(this,"target");M(this,"mode");M(this,"originalGeometry");M(this,"modifiedGeometry",new F);M(this,"timer",0);M(this,"throttling",1e3/15);s.source&&(this.source=s.source),s.target&&(this.target=s.target),this.mode=s.mode||"subtract"}set source(s){this._source=s,this.originalGeometry=this._source.geometry,this.modifiedGeometry.copy(this.originalGeometry),this.source.geometry=this.modifiedGeometry}get source(){return this._source}modify(){if(this._source&&this.target){const s=this._source,o={geometry:this.originalGeometry,matrix:this.source.matrixWorld},e={geometry:this.target.geometry,matrix:this.target.matrixWorld},i=l.fromMesh(o),c=l.fromMesh(e),u=l.toGeometry(i[this.mode](c),s.matrixWorld);this.modifiedGeometry.copy(u)}}render(){this.visible?this.timer||(this.timer=window.setTimeout(()=>{this.modify(),this.timer=0},this.throttling)):this.modifiedGeometry.copy(this.originalGeometry)}apply(){this.originalGeometry.copy(this.modifiedGeometry),this.source.geometry=this.originalGeometry}dispose(){this.source.geometry=this.originalGeometry,this.modifiedGeometry.dispose()}}export{X as B};
