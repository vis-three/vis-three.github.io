var ie=Object.defineProperty;var oe=(i,t,e)=>t in i?ie(i,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):i[t]=e;var dt=(i,t,e)=>(oe(i,typeof t!="symbol"?t+"":t,e),e);import{t as re}from"./index.7d48aff8.js";import{k as Rt,an as st,q as E,V as ft,bJ as Qt,bK as q,bL as Ut,aB as ce,w as Tt,bM as ae,ao as le,aA as Y,a1 as Ht,K as ue,X as fe,a9 as de,v as pe,M as he}from"./three.837c9bb0.js";function me(i,t=!1){const e=i[0].index!==null,s=new Set(Object.keys(i[0].attributes)),n=new Set(Object.keys(i[0].morphAttributes)),c={},r={},u=i[0].morphTargetsRelative,o=new Rt;let d=0;for(let a=0;a<i.length;++a){const f=i[a];let l=0;if(e!==(f.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const p in f.attributes){if(!s.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+'. All geometries must have compatible attributes; make sure "'+p+'" attribute exists among all geometries, or in none of them.'),null;c[p]===void 0&&(c[p]=[]),c[p].push(f.attributes[p]),l++}if(l!==s.size)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". Make sure all geometries have the same number of attributes."),null;if(u!==f.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const p in f.morphAttributes){if(!n.has(p))return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+".  .morphAttributes must be consistent throughout all geometries."),null;r[p]===void 0&&(r[p]=[]),r[p].push(f.morphAttributes[p])}if(o.userData.mergedUserData=o.userData.mergedUserData||[],o.userData.mergedUserData.push(f.userData),t){let p;if(e)p=f.index.count;else if(f.attributes.position!==void 0)p=f.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index "+a+". The geometry must have either an index or a position attribute"),null;o.addGroup(d,p,a),d+=p}}if(e){let a=0;const f=[];for(let l=0;l<i.length;++l){const p=i[l].index;for(let y=0;y<p.count;++y)f.push(p.getX(y)+a);a+=i[l].attributes.position.count}o.setIndex(f)}for(const a in c){const f=Nt(c[a]);if(!f)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+a+" attribute."),null;o.setAttribute(a,f)}for(const a in r){const f=r[a][0].length;if(f===0)break;o.morphAttributes=o.morphAttributes||{},o.morphAttributes[a]=[];for(let l=0;l<f;++l){const p=[];for(let B=0;B<r[a].length;++B)p.push(r[a][B][l]);const y=Nt(p);if(!y)return console.error("THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the "+a+" morphAttribute."),null;o.morphAttributes[a].push(y)}}return o}function Nt(i){let t,e,s,n=0;for(let u=0;u<i.length;++u){const o=i[u];if(o.isInterleavedBufferAttribute)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. InterleavedBufferAttributes are not supported."),null;if(t===void 0&&(t=o.array.constructor),t!==o.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(e===void 0&&(e=o.itemSize),e!==o.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(s===void 0&&(s=o.normalized),s!==o.normalized)return console.error("THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;n+=o.array.length}const c=new t(n);let r=0;for(let u=0;u<i.length;++u)c.set(i[u].array,r),r+=i[u].array.length;return new st(c,e,s)}const te=0,ye=1,xe=2,qt=2,vt=1.25,Gt=1,At=6*4+4+4,Ft=65535,be=Math.pow(2,-24);class pt{constructor(){}}function L(i,t,e){return e.min.x=t[i],e.min.y=t[i+1],e.min.z=t[i+2],e.max.x=t[i+3],e.max.y=t[i+4],e.max.z=t[i+5],e}function Ot(i){let t=-1,e=-1/0;for(let s=0;s<3;s++){const n=i[s+3]-i[s];n>e&&(e=n,t=s)}return t}function kt(i,t){t.set(i)}function Xt(i,t,e){let s,n;for(let c=0;c<3;c++){const r=c+3;s=i[c],n=t[c],e[c]=s<n?s:n,s=i[r],n=t[r],e[r]=s>n?s:n}}function ht(i,t,e){for(let s=0;s<3;s++){const n=t[i+2*s],c=t[i+2*s+1],r=n-c,u=n+c;r<e[s]&&(e[s]=r),u>e[s+3]&&(e[s+3]=u)}}function it(i){const t=i[3]-i[0],e=i[4]-i[1],s=i[5]-i[2];return 2*(t*e+e*s+s*t)}function ge(i,t){if(!i.index){const e=i.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let n;e>65535?n=new Uint32Array(new s(4*e)):n=new Uint16Array(new s(2*e)),i.setIndex(new st(n,1));for(let c=0;c<e;c++)n[c]=c}}function we(i){if(!i.groups||!i.groups.length)return[{offset:0,count:i.index.count/3}];const t=[],e=new Set;for(const n of i.groups)e.add(n.start),e.add(n.start+n.count);const s=Array.from(e.values()).sort((n,c)=>n-c);for(let n=0;n<s.length-1;n++){const c=s[n],r=s[n+1];t.push({offset:c/3,count:(r-c)/3})}return t}function St(i,t,e,s,n=null){let c=1/0,r=1/0,u=1/0,o=-1/0,d=-1/0,a=-1/0,f=1/0,l=1/0,p=1/0,y=-1/0,B=-1/0,w=-1/0;const h=n!==null;for(let x=t*6,m=(t+e)*6;x<m;x+=6){const g=i[x+0],b=i[x+1],A=g-b,T=g+b;A<c&&(c=A),T>o&&(o=T),h&&g<f&&(f=g),h&&g>y&&(y=g);const P=i[x+2],M=i[x+3],v=P-M,S=P+M;v<r&&(r=v),S>d&&(d=S),h&&P<l&&(l=P),h&&P>B&&(B=P);const z=i[x+4],I=i[x+5],U=z-I,F=z+I;U<u&&(u=U),F>a&&(a=F),h&&z<p&&(p=z),h&&z>w&&(w=z)}s[0]=c,s[1]=r,s[2]=u,s[3]=o,s[4]=d,s[5]=a,h&&(n[0]=f,n[1]=l,n[2]=p,n[3]=y,n[4]=B,n[5]=w)}function Ae(i,t,e,s){let n=1/0,c=1/0,r=1/0,u=-1/0,o=-1/0,d=-1/0;for(let a=t*6,f=(t+e)*6;a<f;a+=6){const l=i[a+0];l<n&&(n=l),l>u&&(u=l);const p=i[a+2];p<c&&(c=p),p>o&&(o=p);const y=i[a+4];y<r&&(r=y),y>d&&(d=y)}s[0]=n,s[1]=c,s[2]=r,s[3]=u,s[4]=o,s[5]=d}function Be(i,t,e,s,n){let c=e,r=e+s-1;const u=n.pos,o=n.axis*2;for(;;){for(;c<=r&&t[c*6+o]<u;)c++;for(;c<=r&&t[r*6+o]>=u;)r--;if(c<r){for(let d=0;d<3;d++){let a=i[c*3+d];i[c*3+d]=i[r*3+d],i[r*3+d]=a;let f=t[c*6+d*2+0];t[c*6+d*2+0]=t[r*6+d*2+0],t[r*6+d*2+0]=f;let l=t[c*6+d*2+1];t[c*6+d*2+1]=t[r*6+d*2+1],t[r*6+d*2+1]=l}c++,r--}else return c}}const N=32,Te=(i,t)=>i.candidate-t.candidate,O=new Array(N).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),mt=new Float32Array(6);function Pe(i,t,e,s,n,c){let r=-1,u=0;if(c===te)r=Ot(t),r!==-1&&(u=(t[r]+t[r+3])/2);else if(c===ye)r=Ot(i),r!==-1&&(u=Me(e,s,n,r));else if(c===xe){const o=it(i);let d=vt*n;const a=s*6,f=(s+n)*6;for(let l=0;l<3;l++){const p=t[l],w=(t[l+3]-p)/N;if(n<N/4){const h=[...O];h.length=n;let x=0;for(let g=a;g<f;g+=6,x++){const b=h[x];b.candidate=e[g+2*l],b.count=0;const{bounds:A,leftCacheBounds:T,rightCacheBounds:P}=b;for(let M=0;M<3;M++)P[M]=1/0,P[M+3]=-1/0,T[M]=1/0,T[M+3]=-1/0,A[M]=1/0,A[M+3]=-1/0;ht(g,e,A)}h.sort(Te);let m=n;for(let g=0;g<m;g++){const b=h[g];for(;g+1<m&&h[g+1].candidate===b.candidate;)h.splice(g+1,1),m--}for(let g=a;g<f;g+=6){const b=e[g+2*l];for(let A=0;A<m;A++){const T=h[A];b>=T.candidate?ht(g,e,T.rightCacheBounds):(ht(g,e,T.leftCacheBounds),T.count++)}}for(let g=0;g<m;g++){const b=h[g],A=b.count,T=n-b.count,P=b.leftCacheBounds,M=b.rightCacheBounds;let v=0;A!==0&&(v=it(P)/o);let S=0;T!==0&&(S=it(M)/o);const z=Gt+vt*(v*A+S*T);z<d&&(r=l,d=z,u=b.candidate)}}else{for(let m=0;m<N;m++){const g=O[m];g.count=0,g.candidate=p+w+m*w;const b=g.bounds;for(let A=0;A<3;A++)b[A]=1/0,b[A+3]=-1/0}for(let m=a;m<f;m+=6){let A=~~((e[m+2*l]-p)/w);A>=N&&(A=N-1);const T=O[A];T.count++,ht(m,e,T.bounds)}const h=O[N-1];kt(h.bounds,h.rightCacheBounds);for(let m=N-2;m>=0;m--){const g=O[m],b=O[m+1];Xt(g.bounds,b.rightCacheBounds,g.rightCacheBounds)}let x=0;for(let m=0;m<N-1;m++){const g=O[m],b=g.count,A=g.bounds,P=O[m+1].rightCacheBounds;b!==0&&(x===0?kt(A,mt):Xt(A,mt,mt)),x+=b;let M=0,v=0;x!==0&&(M=it(mt)/o);const S=n-x;S!==0&&(v=it(P)/o);const z=Gt+vt*(M*x+v*S);z<d&&(r=l,d=z,u=g.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:r,pos:u}}function Me(i,t,e,s){let n=0;for(let c=t,r=t+e;c<r;c++)n+=i[c*6+s*2];return n/e}function ve(i,t){const e=i.attributes.position,s=i.index.array,n=s.length/3,c=new Float32Array(n*6),r=e.normalized,u=e.array,o=e.offset||0;let d=3;e.isInterleavedBufferAttribute&&(d=e.data.stride);const a=["getX","getY","getZ"];for(let f=0;f<n;f++){const l=f*3,p=f*6;let y,B,w;r?(y=s[l+0],B=s[l+1],w=s[l+2]):(y=s[l+0]*d+o,B=s[l+1]*d+o,w=s[l+2]*d+o);for(let h=0;h<3;h++){let x,m,g;r?(x=e[a[h]](y),m=e[a[h]](B),g=e[a[h]](w)):(x=u[y+h],m=u[B+h],g=u[w+h]);let b=x;m<b&&(b=m),g<b&&(b=g);let A=x;m>A&&(A=m),g>A&&(A=g);const T=(A-b)/2,P=h*2;c[p+P+0]=b+T,c[p+P+1]=T+(Math.abs(b)+T)*be,b<t[h]&&(t[h]=b),A>t[h+3]&&(t[h+3]=A)}}return c}function Se(i,t){function e(h){l&&l(h/p)}function s(h,x,m,g=null,b=0){if(!y&&b>=o&&(y=!0,d&&(console.warn(`MeshBVH: Max depth of ${o} reached when generating BVH. Consider increasing maxDepth.`),console.warn(i))),m<=a||b>=o)return e(x+m),h.offset=x,h.count=m,h;const A=Pe(h.boundingData,g,r,x,m,f);if(A.axis===-1)return e(x+m),h.offset=x,h.count=m,h;const T=Be(u,r,x,m,A);if(T===x||T===x+m)e(x+m),h.offset=x,h.count=m;else{h.splitAxis=A.axis;const P=new pt,M=x,v=T-x;h.left=P,P.boundingData=new Float32Array(6),St(r,M,v,P.boundingData,c),s(P,M,v,c,b+1);const S=new pt,z=T,I=m-v;h.right=S,S.boundingData=new Float32Array(6),St(r,z,I,S.boundingData,c),s(S,z,I,c,b+1)}return h}ge(i,t);const n=new Float32Array(6),c=new Float32Array(6),r=ve(i,n),u=i.index.array,o=t.maxDepth,d=t.verbose,a=t.maxLeafTris,f=t.strategy,l=t.onProgress,p=i.index.count/3;let y=!1;const B=[],w=we(i);if(w.length===1){const h=w[0],x=new pt;x.boundingData=n,Ae(r,h.offset,h.count,c),s(x,h.offset,h.count,c),B.push(x)}else for(let h of w){const x=new pt;x.boundingData=new Float32Array(6),St(r,h.offset,h.count,x.boundingData,c),s(x,h.offset,h.count,c),B.push(x)}return B}function Ie(i,t){const e=Se(i,t);let s,n,c;const r=[],u=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<e.length;a++){const f=e[a];let l=o(f);const p=new u(At*l);s=new Float32Array(p),n=new Uint32Array(p),c=new Uint16Array(p),d(0,f),r.push(p)}return r;function o(a){return a.count?1:1+o(a.left)+o(a.right)}function d(a,f){const l=a/4,p=a/2,y=!!f.count,B=f.boundingData;for(let w=0;w<6;w++)s[l+w]=B[w];if(y){const w=f.offset,h=f.count;return n[l+6]=w,c[p+14]=h,c[p+15]=Ft,a+At}else{const w=f.left,h=f.right,x=f.splitAxis;let m;if(m=d(a+At,w),m/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return n[l+6]=m/4,m=d(m,h),n[l+7]=x,m}}}class _{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,n=-1/0;for(let c=0,r=t.length;c<r;c++){const o=t[c][e];s=o<s?o:s,n=o>n?o:n}this.min=s,this.max=n}setFromPoints(t,e){let s=1/0,n=-1/0;for(let c=0,r=e.length;c<r;c++){const u=e[c],o=t.dot(u);s=o<s?o:s,n=o>n?o:n}this.min=s,this.max=n}isSeparated(t){return this.min>t.max||t.min>this.max}}_.prototype.setFromBox=function(){const i=new E;return function(e,s){const n=s.min,c=s.max;let r=1/0,u=-1/0;for(let o=0;o<=1;o++)for(let d=0;d<=1;d++)for(let a=0;a<=1;a++){i.x=n.x*o+c.x*(1-o),i.y=n.y*d+c.y*(1-d),i.z=n.z*a+c.z*(1-a);const f=e.dot(i);r=Math.min(f,r),u=Math.max(f,u)}this.min=r,this.max=u}}();(function(){const i=new _;return function(e,s){const n=e.points,c=e.satAxes,r=e.satBounds,u=s.points,o=s.satAxes,d=s.satBounds;for(let a=0;a<3;a++){const f=r[a],l=c[a];if(i.setFromPoints(l,u),f.isSeparated(i))return!1}for(let a=0;a<3;a++){const f=d[a],l=o[a];if(i.setFromPoints(l,n),f.isSeparated(i))return!1}}})();const ze=function(){const i=new E,t=new E,e=new E;return function(n,c,r){const u=n.start,o=i,d=c.start,a=t;e.subVectors(u,d),i.subVectors(n.end,n.start),t.subVectors(c.end,c.start);const f=e.dot(a),l=a.dot(o),p=a.dot(a),y=e.dot(o),w=o.dot(o)*p-l*l;let h,x;w!==0?h=(f*l-y*p)/w:h=0,x=(f+h*l)/p,r.x=h,r.y=x}}(),Dt=function(){const i=new ft,t=new E,e=new E;return function(n,c,r,u){ze(n,c,i);let o=i.x,d=i.y;if(o>=0&&o<=1&&d>=0&&d<=1){n.at(o,r),c.at(d,u);return}else if(o>=0&&o<=1){d<0?c.at(0,u):c.at(1,u),n.closestPointToPoint(u,!0,r);return}else if(d>=0&&d<=1){o<0?n.at(0,r):n.at(1,r),c.closestPointToPoint(r,!0,u);return}else{let a;o<0?a=n.start:a=n.end;let f;d<0?f=c.start:f=c.end;const l=t,p=e;if(n.closestPointToPoint(f,!0,t),c.closestPointToPoint(a,!0,e),l.distanceToSquared(f)<=p.distanceToSquared(a)){r.copy(l),u.copy(f);return}else{r.copy(a),u.copy(p);return}}}}(),Ee=function(){const i=new E,t=new E,e=new Qt,s=new q;return function(c,r){const{radius:u,center:o}=c,{a:d,b:a,c:f}=r;if(s.start=d,s.end=a,s.closestPointToPoint(o,!0,i).distanceTo(o)<=u||(s.start=d,s.end=f,s.closestPointToPoint(o,!0,i).distanceTo(o)<=u)||(s.start=a,s.end=f,s.closestPointToPoint(o,!0,i).distanceTo(o)<=u))return!0;const B=r.getPlane(e);if(Math.abs(B.distanceToPoint(o))<=u){const h=B.projectPoint(o,t);if(r.containsPoint(h))return!0}return!1}}(),Ue=1e-15;function $(i){return Math.abs(i)<Ue}class G extends Ut{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new E),this.satBounds=new Array(4).fill().map(()=>new _),this.points=[this.a,this.b,this.c],this.sphere=new ce,this.plane=new Qt,this.needsUpdate=!0}intersectsSphere(t){return Ee(t,this)}update(){const t=this.a,e=this.b,s=this.c,n=this.points,c=this.satAxes,r=this.satBounds,u=c[0],o=r[0];this.getNormal(u),o.setFromPoints(u,n);const d=c[1],a=r[1];d.subVectors(t,e),a.setFromPoints(d,n);const f=c[2],l=r[2];f.subVectors(e,s),l.setFromPoints(f,n);const p=c[3],y=r[3];p.subVectors(s,t),y.setFromPoints(p,n),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(u,t),this.needsUpdate=!1}}G.prototype.closestPointToSegment=function(){const i=new E,t=new E,e=new q;return function(n,c=null,r=null){const{start:u,end:o}=n,d=this.points;let a,f=1/0;for(let l=0;l<3;l++){const p=(l+1)%3;e.start.copy(d[l]),e.end.copy(d[p]),Dt(e,n,i,t),a=i.distanceToSquared(t),a<f&&(f=a,c&&c.copy(i),r&&r.copy(t))}return this.closestPointToPoint(u,i),a=u.distanceToSquared(i),a<f&&(f=a,c&&c.copy(i),r&&r.copy(u)),this.closestPointToPoint(o,i),a=o.distanceToSquared(i),a<f&&(f=a,c&&c.copy(i),r&&r.copy(o)),Math.sqrt(f)}}();G.prototype.intersectsTriangle=function(){const i=new G,t=new Array(3),e=new Array(3),s=new _,n=new _,c=new E,r=new E,u=new E,o=new E,d=new q,a=new q,f=new q;return function(p,y=null){this.needsUpdate&&this.update(),p.isExtendedTriangle?p.needsUpdate&&p.update():(i.copy(p),i.update(),p=i);const B=this.plane,w=p.plane;if(Math.abs(B.normal.dot(w.normal))>1-1e-10){const h=this.satBounds,x=this.satAxes;e[0]=p.a,e[1]=p.b,e[2]=p.c;for(let b=0;b<4;b++){const A=h[b],T=x[b];if(s.setFromPoints(T,e),A.isSeparated(s))return!1}const m=p.satBounds,g=p.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let b=0;b<4;b++){const A=m[b],T=g[b];if(s.setFromPoints(T,t),A.isSeparated(s))return!1}for(let b=0;b<4;b++){const A=x[b];for(let T=0;T<4;T++){const P=g[T];if(c.crossVectors(A,P),s.setFromPoints(c,t),n.setFromPoints(c,e),s.isSeparated(n))return!1}}return y&&(console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),y.start.set(0,0,0),y.end.set(0,0,0)),!0}else{const h=this.points;let x=!1,m=0;for(let I=0;I<3;I++){const U=h[I],F=h[(I+1)%3];d.start.copy(U),d.end.copy(F),d.delta(r);const V=x?a.start:a.end,C=$(w.distanceToPoint(U));if($(w.normal.dot(r))&&C){a.copy(d),m=2;break}if((w.intersectLine(d,V)||C)&&!$(V.distanceTo(F))){if(m++,x)break;x=!0}}if(m===1&&p.containsPoint(a.end))return y&&(y.start.copy(a.end),y.end.copy(a.end)),!0;if(m!==2)return!1;const g=p.points;let b=!1,A=0;for(let I=0;I<3;I++){const U=g[I],F=g[(I+1)%3];d.start.copy(U),d.end.copy(F),d.delta(u);const V=b?f.start:f.end,C=$(B.distanceToPoint(U));if($(B.normal.dot(u))&&C){f.copy(d),A=2;break}if((B.intersectLine(d,V)||C)&&!$(V.distanceTo(F))){if(A++,b)break;b=!0}}if(A===1&&this.containsPoint(f.end))return y&&(y.start.copy(f.end),y.end.copy(f.end)),!0;if(A!==2)return!1;if(a.delta(r),f.delta(u),r.dot(u)<0){let I=f.start;f.start=f.end,f.end=I}const T=a.start.dot(r),P=a.end.dot(r),M=f.start.dot(r),v=f.end.dot(r),S=P<M,z=T<v;return T!==v&&M!==P&&S===z?!1:(y&&(o.subVectors(a.start,f.start),o.dot(r)>0?y.start.copy(a.start):y.start.copy(f.start),o.subVectors(a.end,f.end),o.dot(r)<0?y.end.copy(a.end):y.end.copy(f.end)),!0)}}}();G.prototype.distanceToPoint=function(){const i=new E;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();G.prototype.distanceToTriangle=function(){const i=new E,t=new E,e=["a","b","c"],s=new q,n=new q;return function(r,u=null,o=null){const d=u||o?s:null;if(this.intersectsTriangle(r,d))return(u||o)&&(u&&d.getCenter(u),o&&d.getCenter(o)),0;let a=1/0;for(let f=0;f<3;f++){let l;const p=e[f],y=r[p];this.closestPointToPoint(y,i),l=y.distanceToSquared(i),l<a&&(a=l,u&&u.copy(i),o&&o.copy(y));const B=this[p];r.closestPointToPoint(B,i),l=B.distanceToSquared(i),l<a&&(a=l,u&&u.copy(B),o&&o.copy(i))}for(let f=0;f<3;f++){const l=e[f],p=e[(f+1)%3];s.set(this[l],this[p]);for(let y=0;y<3;y++){const B=e[y],w=e[(y+1)%3];n.set(r[B],r[w]),Dt(s,n,i,t);const h=i.distanceToSquared(t);h<a&&(a=h,u&&u.copy(i),o&&o.copy(t))}}return Math.sqrt(a)}}();class H{constructor(t,e,s){this.isOrientedBox=!0,this.min=new E,this.max=new E,this.matrix=new Tt,this.invMatrix=new Tt,this.points=new Array(8).fill().map(()=>new E),this.satAxes=new Array(3).fill().map(()=>new E),this.satBounds=new Array(3).fill().map(()=>new _),this.alignedSatBounds=new Array(3).fill().map(()=>new _),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}H.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,n=this.points;for(let d=0;d<=1;d++)for(let a=0;a<=1;a++)for(let f=0;f<=1;f++){const l=1*d|2*a|4*f,p=n[l];p.x=d?s.x:e.x,p.y=a?s.y:e.y,p.z=f?s.z:e.z,p.applyMatrix4(t)}const c=this.satBounds,r=this.satAxes,u=n[0];for(let d=0;d<3;d++){const a=r[d],f=c[d],l=1<<d,p=n[l];a.subVectors(u,p),f.setFromPoints(a,n)}const o=this.alignedSatBounds;o[0].setFromPointsField(n,"x"),o[1].setFromPointsField(n,"y"),o[2].setFromPointsField(n,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();H.prototype.intersectsBox=function(){const i=new _;return function(e){this.needsUpdate&&this.update();const s=e.min,n=e.max,c=this.satBounds,r=this.satAxes,u=this.alignedSatBounds;if(i.min=s.x,i.max=n.x,u[0].isSeparated(i)||(i.min=s.y,i.max=n.y,u[1].isSeparated(i))||(i.min=s.z,i.max=n.z,u[2].isSeparated(i)))return!1;for(let o=0;o<3;o++){const d=r[o],a=c[o];if(i.setFromBox(d,e),a.isSeparated(i))return!1}return!0}}();H.prototype.intersectsTriangle=function(){const i=new G,t=new Array(3),e=new _,s=new _,n=new E;return function(r){this.needsUpdate&&this.update(),r.isExtendedTriangle?r.needsUpdate&&r.update():(i.copy(r),i.update(),r=i);const u=this.satBounds,o=this.satAxes;t[0]=r.a,t[1]=r.b,t[2]=r.c;for(let l=0;l<3;l++){const p=u[l],y=o[l];if(e.setFromPoints(y,t),p.isSeparated(e))return!1}const d=r.satBounds,a=r.satAxes,f=this.points;for(let l=0;l<3;l++){const p=d[l],y=a[l];if(e.setFromPoints(y,f),p.isSeparated(e))return!1}for(let l=0;l<3;l++){const p=o[l];for(let y=0;y<4;y++){const B=a[y];if(n.crossVectors(p,B),e.setFromPoints(n,t),s.setFromPoints(n,f),e.isSeparated(s))return!1}}return!0}}();H.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();H.prototype.distanceToPoint=function(){const i=new E;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();H.prototype.distanceToBox=function(){const i=["x","y","z"],t=new Array(12).fill().map(()=>new q),e=new Array(12).fill().map(()=>new q),s=new E,n=new E;return function(r,u=0,o=null,d=null){if(this.needsUpdate&&this.update(),this.intersectsBox(r))return(o||d)&&(r.getCenter(n),this.closestPointToPoint(n,s),r.closestPointToPoint(s,n),o&&o.copy(s),d&&d.copy(n)),0;const a=u*u,f=r.min,l=r.max,p=this.points;let y=1/0;for(let w=0;w<8;w++){const h=p[w];n.copy(h).clamp(f,l);const x=h.distanceToSquared(n);if(x<y&&(y=x,o&&o.copy(h),d&&d.copy(n),x<a))return Math.sqrt(x)}let B=0;for(let w=0;w<3;w++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){const m=(w+1)%3,g=(w+2)%3,b=h<<m|x<<g,A=1<<w|h<<m|x<<g,T=p[b],P=p[A];t[B].set(T,P);const v=i[w],S=i[m],z=i[g],I=e[B],U=I.start,F=I.end;U[v]=f[v],U[S]=h?f[S]:l[S],U[z]=x?f[z]:l[S],F[v]=l[v],F[S]=h?f[S]:l[S],F[z]=x?f[z]:l[S],B++}for(let w=0;w<=1;w++)for(let h=0;h<=1;h++)for(let x=0;x<=1;x++){n.x=w?l.x:f.x,n.y=h?l.y:f.y,n.z=x?l.z:f.z,this.closestPointToPoint(n,s);const m=n.distanceToSquared(s);if(m<y&&(y=m,o&&o.copy(s),d&&d.copy(n),m<a))return Math.sqrt(m)}for(let w=0;w<12;w++){const h=t[w];for(let x=0;x<12;x++){const m=e[x];Dt(h,m,s,n);const g=s.distanceToSquared(n);if(g<y&&(y=g,o&&o.copy(s),d&&d.copy(n),g<a))return Math.sqrt(g)}}return Math.sqrt(y)}}();const yt=new E,xt=new E,bt=new E,jt=new ft,Wt=new ft,Yt=new ft,Zt=new E;function Fe(i,t,e,s,n,c){let r;return c===ae?r=i.intersectTriangle(s,e,t,!0,n):r=i.intersectTriangle(t,e,s,c!==le,n),r===null?null:{distance:i.origin.distanceTo(n),point:n.clone()}}function Ce(i,t,e,s,n,c,r){yt.fromBufferAttribute(t,s),xt.fromBufferAttribute(t,n),bt.fromBufferAttribute(t,c);const u=Fe(i,yt,xt,bt,Zt,r);if(u){e&&(jt.fromBufferAttribute(e,s),Wt.fromBufferAttribute(e,n),Yt.fromBufferAttribute(e,c),u.uv=Ut.getUV(Zt,yt,xt,bt,jt,Wt,Yt,new ft));const o={a:s,b:n,c,normal:new E,materialIndex:0};Ut.getNormal(yt,xt,bt,o.normal),u.face=o,u.faceIndex=s}return u}function ee(i,t,e,s,n){const c=s*3,r=i.index.getX(c),u=i.index.getX(c+1),o=i.index.getX(c+2),d=Ce(e,i.attributes.position,i.attributes.uv,r,u,o,t);return d?(d.faceIndex=s,n&&n.push(d),d):null}function Ve(i,t,e,s,n,c){for(let r=s,u=s+n;r<u;r++)ee(i,t,e,r,c)}function Le(i,t,e,s,n){let c=1/0,r=null;for(let u=s,o=s+n;u<o;u++){const d=ee(i,t,e,u);d&&d.distance<c&&(r=d,c=d.distance)}return r}function D(i,t,e,s){const n=i.a,c=i.b,r=i.c;let u=t,o=t+1,d=t+2;e&&(u=e.getX(t),o=e.getX(t+1),d=e.getX(t+2)),n.x=s.getX(u),n.y=s.getY(u),n.z=s.getZ(u),c.x=s.getX(o),c.y=s.getY(o),c.z=s.getZ(o),r.x=s.getX(d),r.y=s.getY(d),r.z=s.getZ(d)}function Kt(i,t,e,s,n,c,r){const u=e.index,o=e.attributes.position;for(let d=i,a=t+i;d<a;d++)if(D(r,d*3,u,o),r.needsUpdate=!0,s(r,d,n,c))return!0;return!1}class se{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function k(i,t){return t[i+15]===65535}function tt(i,t){return t[i+6]}function at(i,t){return t[i+14]}function lt(i){return i+8}function ut(i,t){return t[i+6]}function Re(i,t){return t[i+7]}const Q=new Y,Pt=new E,De=["x","y","z"];function Ct(i,t,e,s,n){let c=i*2,r=nt,u=X,o=j;if(k(c,u)){const a=tt(i,o),f=at(c,u);Ve(t,e,s,a,f,n)}else{const a=lt(i);Mt(a,r,s,Pt)&&Ct(a,t,e,s,n);const f=ut(i,o);Mt(f,r,s,Pt)&&Ct(f,t,e,s,n)}}function Vt(i,t,e,s){let n=i*2,c=nt,r=X,u=j;if(k(n,r)){const d=tt(i,u),a=at(n,r);return Le(t,e,s,d,a)}else{const d=Re(i,u),a=De[d],l=s.direction[a]>=0;let p,y;l?(p=lt(i),y=ut(i,u)):(p=ut(i,u),y=lt(i));const w=Mt(p,c,s,Pt)?Vt(p,t,e,s):null;if(w){const m=w.point[a];if(l?m<=c[y+d]:m>=c[y+d+3])return w}const x=Mt(y,c,s,Pt)?Vt(y,t,e,s):null;return w&&x?w.distance<=x.distance?w:x:w||x||null}}const _e=function(){let i,t;const e=[],s=new se(()=>new Y);return function(...r){i=s.getPrimitive(),t=s.getPrimitive(),e.push(i,t);const u=n(...r);s.releasePrimitive(i),s.releasePrimitive(t),e.pop(),e.pop();const o=e.length;return o>0&&(t=e[o-1],i=e[o-2]),u};function n(c,r,u,o,d=null,a=0,f=0){function l(m){let g=m*2,b=X,A=j;for(;!k(g,b);)m=lt(m),g=m*2;return tt(m,A)}function p(m){let g=m*2,b=X,A=j;for(;!k(g,b);)m=ut(m,A),g=m*2;return tt(m,A)+at(g,b)}let y=c*2,B=nt,w=X,h=j;if(k(y,w)){const m=tt(c,h),g=at(y,w);return L(c,B,i),o(m,g,!1,f,a+c,i)}else{const m=lt(c),g=ut(c,h);let b=m,A=g,T,P,M,v;if(d&&(M=i,v=t,L(b,B,M),L(A,B,v),T=d(M),P=d(v),P<T)){b=g,A=m;const C=T;T=P,P=C,M=v}M||(M=i,L(b,B,M));const S=k(b*2,w),z=u(M,S,T,f+1,a+b);let I;if(z===qt){const C=l(b),K=p(b)-C;I=o(C,K,!0,f+1,a+b,M)}else I=z&&n(b,r,u,o,d,a,f+1);if(I)return!0;v=t,L(A,B,v);const U=k(A*2,w),F=u(v,U,P,f+1,a+A);let V;if(F===qt){const C=l(A),K=p(A)-C;V=o(C,K,!0,f+1,a+A,v)}else V=F&&n(A,r,u,o,d,a,f+1);return!!V}}}(),He=function(){const i=new G,t=new G,e=new Tt,s=new H,n=new H;return function c(r,u,o,d,a=null){let f=r*2,l=nt,p=X,y=j;if(a===null&&(o.boundingBox||o.computeBoundingBox(),s.set(o.boundingBox.min,o.boundingBox.max,d),a=s),k(f,p)){const w=u,h=w.index,x=w.attributes.position,m=o.index,g=o.attributes.position,b=tt(r,y),A=at(f,p);if(e.copy(d).invert(),o.boundsTree)return L(r,l,n),n.matrix.copy(e),n.needsUpdate=!0,o.boundsTree.shapecast({intersectsBounds:P=>n.intersectsBox(P),intersectsTriangle:P=>{P.a.applyMatrix4(d),P.b.applyMatrix4(d),P.c.applyMatrix4(d),P.needsUpdate=!0;for(let M=b*3,v=(A+b)*3;M<v;M+=3)if(D(t,M,h,x),t.needsUpdate=!0,P.intersectsTriangle(t))return!0;return!1}});for(let T=b*3,P=A+b*3;T<P;T+=3){D(i,T,h,x),i.a.applyMatrix4(e),i.b.applyMatrix4(e),i.c.applyMatrix4(e),i.needsUpdate=!0;for(let M=0,v=m.count;M<v;M+=3)if(D(t,M,m,g),t.needsUpdate=!0,i.intersectsTriangle(t))return!0}}else{const w=r+8,h=y[r+6];return L(w,l,Q),!!(a.intersectsBox(Q)&&c(w,u,o,d,a)||(L(h,l,Q),a.intersectsBox(Q)&&c(h,u,o,d,a)))}}}();function Mt(i,t,e,s){return L(i,t,Q),e.intersectBox(Q,s)}const Lt=[];let Bt,nt,X,j;function ct(i){Bt&&Lt.push(Bt),Bt=i,nt=new Float32Array(i),X=new Uint16Array(i),j=new Uint32Array(i)}function gt(){Bt=null,nt=null,X=null,j=null,Lt.length&&ct(Lt.pop())}const It=Symbol("skip tree generation"),zt=new Y,Et=new Y,J=new Tt,W=new H,ot=new H,rt=new E,wt=new E,Ne=new E,qe=new E,Ge=new E,$t=new Y,R=new se(()=>new G);class et{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),et.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e={cloneBuffers:!0,...e};const s=t.geometry,n=t._roots,c=s.getIndex();let r;return e.cloneBuffers?r={roots:n.map(u=>u.slice()),index:c.array.slice()}:r={roots:n,index:c.array},r}static deserialize(t,e,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),et.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:n,roots:c}=t,r=new et(e,{...s,[It]:!0});if(r._roots=c,s.setIndex){const u=e.getIndex();if(u===null){const o=new st(t.index,1,!1);e.setIndex(o)}else u.array!==n&&(u.array.set(n),u.needsUpdate=!0)}return r}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:te,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[It]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer=="undefined")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[It]||(this._roots=Ie(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new Y))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,s=e.index.array,n=e.attributes.position;let c,r,u,o,d=0;const a=this._roots;for(let l=0,p=a.length;l<p;l++)c=a[l],r=new Uint32Array(c),u=new Uint16Array(c),o=new Float32Array(c),f(0,d),d+=c.byteLength;function f(l,p,y=!1){const B=l*2;if(u[B+15]===Ft){const h=r[l+6],x=u[B+14];let m=1/0,g=1/0,b=1/0,A=-1/0,T=-1/0,P=-1/0;for(let M=3*h,v=3*(h+x);M<v;M++){const S=s[M],z=n.getX(S),I=n.getY(S),U=n.getZ(S);z<m&&(m=z),z>A&&(A=z),I<g&&(g=I),I>T&&(T=I),U<b&&(b=U),U>P&&(P=U)}return o[l+0]!==m||o[l+1]!==g||o[l+2]!==b||o[l+3]!==A||o[l+4]!==T||o[l+5]!==P?(o[l+0]=m,o[l+1]=g,o[l+2]=b,o[l+3]=A,o[l+4]=T,o[l+5]=P,!0):!1}else{const h=l+8,x=r[l+6],m=h+p,g=x+p;let b=y,A=!1,T=!1;t?b||(A=t.has(m),T=t.has(g),b=!A&&!T):(A=!0,T=!0);const P=b||A,M=b||T;let v=!1;P&&(v=f(h,p,b));let S=!1;M&&(S=f(x,p,b));const z=v||S;if(z)for(let I=0;I<3;I++){const U=h+I,F=x+I,V=o[U],C=o[U+3],Z=o[F],K=o[F+3];o[l+I]=V<Z?V:Z,o[l+I+3]=C>K?C:K}return z}}}traverse(t,e=0){const s=this._roots[e],n=new Uint32Array(s),c=new Uint16Array(s);r(0);function r(u,o=0){const d=u*2,a=c[d+15]===Ft;if(a){const f=n[u+6],l=c[d+14];t(o,a,new Float32Array(s,u*4,6),f,l)}else{const f=u+At/4,l=n[u+6],p=n[u+7];t(o,a,new Float32Array(s,u*4,6),p)||(r(f,o+1),r(l,o+1))}}}raycast(t,e=Ht){const s=this._roots,n=this.geometry,c=[],r=e.isMaterial,u=Array.isArray(e),o=n.groups,d=r?e.side:e;for(let a=0,f=s.length;a<f;a++){const l=u?e[o[a].materialIndex].side:d,p=c.length;if(ct(s[a]),Ct(0,n,l,t,c),gt(),u){const y=o[a].materialIndex;for(let B=p,w=c.length;B<w;B++)c[B].face.materialIndex=y}}return c}raycastFirst(t,e=Ht){const s=this._roots,n=this.geometry,c=e.isMaterial,r=Array.isArray(e);let u=null;const o=n.groups,d=c?e.side:e;for(let a=0,f=s.length;a<f;a++){const l=r?e[o[a].materialIndex].side:d;ct(s[a]);const p=Vt(0,n,l,t);gt(),p!=null&&(u==null||p.distance<u.distance)&&(u=p,r&&(p.face.materialIndex=o[a].materialIndex))}return u}intersectsGeometry(t,e){const s=this.geometry;let n=!1;for(const c of this._roots)if(ct(c),n=He(0,s,t,e),gt(),n)break;return n}shapecast(t,e,s){const n=this.geometry;if(t instanceof Function){if(e){const l=e;e=(p,y,B,w)=>{const h=y*3;return l(p,h,h+1,h+2,B,w)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const c=R.getPrimitive();let{boundsTraverseOrder:r,intersectsBounds:u,intersectsRange:o,intersectsTriangle:d}=t;if(o&&d){const l=o;o=(p,y,B,w,h)=>l(p,y,B,w,h)?!0:Kt(p,y,n,d,B,w,c)}else o||(d?o=(l,p,y,B)=>Kt(l,p,n,d,y,B,c):o=(l,p,y)=>y);let a=!1,f=0;for(const l of this._roots){if(ct(l),a=_e(0,n,u,o,r,f),gt(),a)break;f+=l.byteLength}return R.releasePrimitive(c),a}bvhcast(t,e,s){let{intersectsRanges:n,intersectsTriangles:c}=s;const r=this.geometry.index,u=this.geometry.attributes.position,o=t.geometry.index,d=t.geometry.attributes.position;J.copy(e).invert();const a=R.getPrimitive(),f=R.getPrimitive();if(c){let p=function(y,B,w,h,x,m,g,b){for(let A=w,T=w+h;A<T;A++){D(f,A*3,o,d),f.a.applyMatrix4(e),f.b.applyMatrix4(e),f.c.applyMatrix4(e),f.needsUpdate=!0;for(let P=y,M=y+B;P<M;P++)if(D(a,P*3,r,u),a.needsUpdate=!0,c(a,f,P,A,x,m,g,b))return!0}return!1};if(n){const y=n;n=function(B,w,h,x,m,g,b,A){return y(B,w,h,x,m,g,b,A)?!0:p(B,w,h,x,m,g,b,A)}}else n=p}t.getBoundingBox(Et),Et.applyMatrix4(e);const l=this.shapecast({intersectsBounds:p=>Et.intersectsBox(p),intersectsRange:(p,y,B,w,h,x)=>(zt.copy(x),zt.applyMatrix4(J),t.shapecast({intersectsBounds:m=>zt.intersectsBox(m),intersectsRange:(m,g,b,A,T)=>n(p,y,m,g,w,h,A,T)}))});return R.releasePrimitive(a),R.releasePrimitive(f),l}intersectsBox(t,e){return W.set(t.min,t.max,e),W.needsUpdate=!0,this.shapecast({intersectsBounds:s=>W.intersectsBox(s),intersectsTriangle:s=>W.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},n={},c=0,r=1/0){t.boundingBox||t.computeBoundingBox(),W.set(t.boundingBox.min,t.boundingBox.max,e),W.needsUpdate=!0;const u=this.geometry,o=u.attributes.position,d=u.index,a=t.attributes.position,f=t.index,l=R.getPrimitive(),p=R.getPrimitive();let y=wt,B=Ne,w=null,h=null;n&&(w=qe,h=Ge);let x=1/0,m=null,g=null;return J.copy(e).invert(),ot.matrix.copy(J),this.shapecast({boundsTraverseOrder:b=>W.distanceToBox(b),intersectsBounds:(b,A,T)=>T<x&&T<r?(A&&(ot.min.copy(b.min),ot.max.copy(b.max),ot.needsUpdate=!0),!0):!1,intersectsRange:(b,A)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:T=>ot.distanceToBox(T),intersectsBounds:(T,P,M)=>M<x&&M<r,intersectsRange:(T,P)=>{for(let M=T*3,v=(T+P)*3;M<v;M+=3){D(p,M,f,a),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let S=b*3,z=(b+A)*3;S<z;S+=3){D(l,S,d,o),l.needsUpdate=!0;const I=l.distanceToTriangle(p,y,w);if(I<x&&(B.copy(y),h&&h.copy(w),x=I,m=S/3,g=M/3),I<c)return!0}}}});{const T=f?f.count:a.count;for(let P=0,M=T;P<M;P+=3){D(p,P,f,a),p.a.applyMatrix4(e),p.b.applyMatrix4(e),p.c.applyMatrix4(e),p.needsUpdate=!0;for(let v=b*3,S=(b+A)*3;v<S;v+=3){D(l,v,d,o),l.needsUpdate=!0;const z=l.distanceToTriangle(p,y,w);if(z<x&&(B.copy(y),h&&h.copy(w),x=z,m=v/3,g=P/3),z<c)return!0}}}}}),R.releasePrimitive(l),R.releasePrimitive(p),x===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=x,s.faceIndex=m,n&&(n.point?n.point.copy(h):n.point=h.clone(),n.point.applyMatrix4(J),B.applyMatrix4(J),n.distance=B.sub(n.point).length(),n.faceIndex=g),s)}closestPointToPoint(t,e={},s=0,n=1/0){const c=s*s,r=n*n;let u=1/0,o=null;if(this.shapecast({boundsTraverseOrder:a=>(rt.copy(t).clamp(a.min,a.max),rt.distanceToSquared(t)),intersectsBounds:(a,f,l)=>l<u&&l<r,intersectsTriangle:(a,f)=>{a.closestPointToPoint(t,rt);const l=t.distanceToSquared(rt);return l<u&&(wt.copy(rt),u=l,o=f),l<c}}),u===1/0)return null;const d=Math.sqrt(u);return e.point?e.point.copy(wt):e.point=wt.clone(),e.distance=d,e.faceIndex=o,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{L(0,new Float32Array(s),$t),t.union($t)}),t}}const Jt=new Y;class Oe extends pe{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,s=10,n=0){super(),this.material=e,this.geometry=new Rt,this.name="MeshBVHRootVisualizer",this.depth=s,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=n}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,s=this._group;if(t.dispose(),this.visible=!1,e){const n=this.depth-1,c=this.displayParents;let r=0;e.traverse((l,p)=>{if(l===n||p)return r++,!0;c&&r++},s);let u=0;const o=new Float32Array(8*3*r);e.traverse((l,p,y)=>{const B=l===n||p;if(B||c){L(0,y,Jt);const{min:w,max:h}=Jt;for(let x=-1;x<=1;x+=2){const m=x<0?w.x:h.x;for(let g=-1;g<=1;g+=2){const b=g<0?w.y:h.y;for(let A=-1;A<=1;A+=2){const T=A<0?w.z:h.z;o[u+0]=m,o[u+1]=b,o[u+2]=T,u+=3}}}return B}},s);let d,a;this.displayEdges?a=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):a=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),o.length>65535?d=new Uint32Array(a.length*r):d=new Uint16Array(a.length*r);const f=a.length;for(let l=0;l<r;l++){const p=l*8,y=l*f;for(let B=0;B<f;B++)d[y+B]=p+a[B]}t.setIndex(new st(d,1,!1)),t.setAttribute("position",new st(o,3,!1)),this.visible=!0}}}class _t extends ue{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const s=new fe({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),n=new de({color:65416,transparent:!0,opacity:.3,depthWrite:!1});n.color=s.color,this.edgeMaterial=s,this.meshMaterial=n,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;){const s=this._roots.pop();s.geometry.dispose(),this.remove(s)}for(let s=0;s<e;s++){if(s>=this._roots.length){const c=new Oe(this.mesh,this.edgeMaterial,this.depth,s);this.add(c),this._roots.push(c)}const n=this._roots[s];n.depth=this.depth,n.mesh=this.mesh,n.displayParents=this.displayParents,n.displayEdges=this.displayEdges,n.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,n.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new _t(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].geometry.dispose()}}const ne=new Rt;ne.setAttribute("position",new st(new Float32Array([0,0,0,0,0,0,0,0,0]),3));class ke{constructor(){dt(this,"bvh",new et(ne));dt(this,"visualizer");dt(this,"castOptions",{intersectsBounds:t=>!1,intersectsTriangle:()=>{}})}addBVH(t){const e=t.geometry.clone();e.applyMatrix4(t.matrixWorld);for(const s in e.attributes)s!=="position"&&e.deleteAttribute(s);this.bvh=new et(me([this.bvh.geometry,e])),this.bvh.geometry.boundsTree=this.bvh,this.visualizer&&(this.visualizer.mesh.geometry=this.bvh.geometry,this.visualizer.update())}createVisualizer(){return this.visualizer=new _t(new he(this.bvh.geometry)),this}shapecast(t){return this.bvh.shapecast(t||this.castOptions)}dispose(){var t;(t=this.visualizer)==null||t.dispose(),this.bvh.geometry.dispose()}}const Xe="@vis-three/plugin-mesh-bvh",je=re(Xe),Ke=function(i={}){return{name:je,install(t){const e=new ke;i.visualizer&&(e.createVisualizer(),t.scene.add(e.visualizer)),i.shapecast&&(e.castOptions=i.shapecast),t.meshBVHManager=e,t.addBVH=function(s){return e.addBVH(s),t}},dispose(t){t.meshBVHManager.dispose(),delete t.meshBVHManager,delete t.addBVH}}};export{Ke as M,me as m};
