import{t as T,a as D,b as re,E as oe}from"./index.f2ecf0d4.js";import{R as ae}from"./index.e11efb4f.js";import{W as ne}from"./index.62b980cf.js";import{P as le}from"./vis-three.plugin-pointer-manager.es.d581852e.js";import{b as k,E as ce}from"./index.1a70533e.js";import{E as he,a as de}from"./index.134e4e63.js";import{C as pe,O as me,a as ue,b as ge}from"./index.8d7364ed.js";import{C as fe}from"./index.45f20074.js";import{S as $,T as ye,a as j,b as xe,A as ve,V as be,c as Se,d as we,K as Me,O as Pe,e as He,G as Ee,f as Ce}from"./index.4918a762.js";import{G as je}from"./index.24c0872b.js";import{K as f,k as C,l as W,bC as We,w as Ae,h as Be,O as De,o as x,b2 as w,ba as v,z as K,az as G,q as P,M as Oe,bD as z,a5 as Re,ay as Fe,b as L,aj as Ue,I as O,bE as Te,bv as R,i as F,a$ as Ge,a_ as Le,V as Ve,S as A,E as Ne}from"./three.9c0f0dc6.js";import{C as U}from"./vis-three.convenient.es.421933a2.js";import{C as _e,a as ze}from"./index.246dda8d.js";import{M as Ie}from"./vis-three.strategy-multi-renderer.es.73c1d64a.js";var ke=Object.defineProperty,$e=(t,e,i)=>e in t?ke(t,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):t[e]=i,r=(t,e,i)=>($e(t,typeof e!="symbol"?e+"":e,i),i);const M=()=>new K({color:"rgb(255, 255, 255)"});class I extends f{constructor(e){super(),r(this,"shape"),r(this,"target"),r(this,"type","CameraHelper"),r(this,"cachaData");const i=new C,s=[0,0,0,-1,1,-1,0,0,0,-1,1,1,0,0,0,-1,-1,-1,0,0,0,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,-1,1,0,0,0,0,1,1,0,0,0,0,1,-1,0,0,0,0,-1,-1,0,0,0,0,-1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0,-1,-1,0,-1,1,0,-1,1,0,1,1,0,-1,1,2,-1,1,0,1,-1,2,1,-1,0,-1,-1,2,-1,-1,0,1,1,2,1,1,2,1,1,2,-1,1,2,-1,1,2,-1,-1,2,-1,-1,2,1,-1,2,1,-1,2,1,1];i.setAttribute("position",new W(s,3)),i.rotateY(-90*Math.PI/180),i.computeBoundingBox();const o=new We(e);o.matrix=new Ae,o.matrixAutoUpdate=!0,o.raycast=()=>{},this.add(o),this.shape=o,this.geometry=i,this.material=M(),this.target=e,this.matrixAutoUpdate=!1,this.matrix=e.matrix,e instanceof Be?this.cachaData={fov:e.fov,aspect:e.aspect,near:e.near,far:e.far}:e instanceof De?this.cachaData={left:e.left,right:e.right,top:e.top,bottom:e.bottom,near:e.near,far:e.far}:this.cachaData={},this.onBeforeRender=()=>{let n=!1;const l=this.cachaData;Object.keys(l).forEach(p=>{l[p]!==e[p]&&(l[p]=e[p],n=!0)}),n&&this.shape.update()}}raycast(e,i){const s=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(s),e.ray.intersectsBox(o)){const n=this.target;i.push({distance:e.ray.origin.distanceTo(n.position),object:n,point:n.position})}}}class Ke extends f{constructor(e){super(),r(this,"sphere"),r(this,"target"),r(this,"shape"),r(this,"type","VisDirectionalLightHelper"),r(this,"cacheColor"),r(this,"cacheVector3"),this.geometry=new C;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new W(i,3)),this.material=M(),this.geometry.boundingSphere;const s=new x().copy(e.color).multiplyScalar(e.intensity),o=new w(20,20);o.dispose();const n=new f(new v(o),new K({color:s}));n.raycast=()=>{},this.shape=n,this.target=e,this.sphere=new G(new P(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheVector3=new P,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const l=this.target,p=this.shape;l.color.getHex()!==this.cacheColor&&(p.material.color.copy(l.color).multiplyScalar(l.intensity),this.cacheColor=l.color.getHex()),p.lookAt(l.target.position)}}raycast(e,i){const s=this.target,o=s.matrixWorld,n=this.sphere;n.set(this.cacheVector3.set(0,0,0),1),n.applyMatrix4(o),e.ray.intersectsSphere(n)&&i.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}}class Ye extends f{constructor(e){super(),r(this,"sphere"),r(this,"target"),r(this,"shape"),r(this,"type","VisPointLightHelper"),r(this,"cacheColor"),r(this,"cacheDistance"),r(this,"cacheVector3"),this.geometry=new C;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new W(i,3)),this.material=M(),this.geometry.boundingSphere;const s=new x().copy(e.color).multiplyScalar(e.intensity),o=new Oe(new z(e.distance,0),new Re({color:s,wireframe:!0}));o.raycast=()=>{},o.matrixAutoUpdate=!1,this.shape=o,this.target=e,this.sphere=new G(new P(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheVector3=new P,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const n=this.target,l=this.shape;n.distance!==this.cacheDistance&&(l.geometry.dispose(),l.geometry=new z(n.distance,0),this.cacheDistance=n.distance),n.color.getHex()!==this.cacheColor&&(l.material.color.copy(n.color).multiplyScalar(n.intensity),this.cacheColor=n.color.getHex())}}raycast(e,i){const s=this.target,o=s.matrixWorld,n=this.sphere;n.set(this.cacheVector3.set(0,0,0),1),n.applyMatrix4(o),e.ray.intersectsSphere(n)&&i.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}}class qe extends f{constructor(e){super(),r(this,"target"),r(this,"type","VisRectAreaLightHelper"),r(this,"cacheBox",new Fe),r(this,"cacheVector3",new P),r(this,"cacheColor"),r(this,"cacheIntensity"),this.target=e,this.generateShape();const i=M();i.color.copy(e.color).multiplyScalar(e.intensity),this.cacheColor=e.color.getHex(),this.cacheIntensity=e.intensity,this.material=i,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.onBeforeRender=()=>{const s=this.target;(s.width!==this.geometry.parameters.width||s.height!==this.geometry.parameters.height)&&this.generateShape(),(s.color.getHex()!==this.cacheColor||this.cacheIntensity!==s.intensity)&&(this.material.color.copy(s.color).multiplyScalar(s.intensity),this.cacheColor=s.color.getHex())}}generateShape(){this.geometry.dispose(),this.geometry=new w(this.target.width,this.target.height,4,4),this.geometry.computeBoundingBox()}raycast(e,i){const s=this.target,o=this.cacheBox;o.copy(this.geometry.boundingBox),o.applyMatrix4(s.matrixWorld),e.ray.intersectBox(o,this.cacheVector3)&&i.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}}class Je extends f{constructor(e){super(),r(this,"sphere"),r(this,"target"),r(this,"shape"),r(this,"type","VisSpotLightHelper"),r(this,"cacheVector3"),r(this,"cacheColor"),r(this,"cacheAngle"),r(this,"cacheDistance"),this.geometry=new C;const i=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new W(i,3)),this.material=M(),this.geometry.boundingSphere;const s=new C,o=[0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let a=0,h=1,m=32;a<m;a++,h++){const y=a/m*Math.PI*2,B=h/m*Math.PI*2;o.push(Math.cos(y),Math.sin(y),1,Math.cos(B),Math.sin(B),1)}s.setAttribute("position",new W(o,3));const n=M(),l=new f(s,n);l.material.color.copy(e.color).multiplyScalar(e.intensity);const p=e.distance?e.distance:1e3,d=p*Math.tan(e.angle);l.scale.set(d,d,p),l.raycast=()=>{},this.add(l),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e,this.shape=l,this.sphere=new G(new P(0,0,0),1),this.cacheColor=e.color.getHex(),this.cacheDistance=e.distance,this.cacheAngle=e.angle,this.cacheVector3=new P,this.onBeforeRender=()=>{const a=this.target,h=this.shape;let m=!1;if(a.distance!==this.cacheDistance&&(this.cacheDistance=a.distance,h.scale.z=a.distance,m=!0),a.angle!==this.cacheAngle&&(this.cacheAngle=a.angle,m=!0),m){const y=a.distance*Math.tan(a.angle);h.scale.set(y,y,a.distance)}a.color.getHex()!==this.cacheColor&&(h.material.color.copy(a.color).multiplyScalar(a.intensity),this.cacheColor=a.color.getHex()),h.lookAt(a.target.position)}}raycast(e,i){const s=this.target,o=s.matrixWorld,n=this.sphere;n.set(this.cacheVector3.set(0,0,0),1),n.applyMatrix4(o),e.ray.intersectsSphere(n)&&i.push({distance:e.ray.origin.distanceTo(s.position),object:s,point:s.position})}}const Y=class extends L{constructor(t){super(),r(this,"target"),r(this,"type","GeometricOriginHelper"),this.target=t,this.geometry=new C().setAttribute("position",new Ue(new Float32Array([0,0,0]),3)),this.material=new O({map:Y.colorTexture,transparent:!0,alphaTest:.1,depthFunc:Te}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}};let Qe=Y;r(Qe,"colorTexture",new R(new U({width:32,height:32}).draw(t=>{t.beginPath(),t.fillStyle="rgba(0, 0, 0, 0)",t.fillRect(0,0,32,32),t.closePath(),t.beginPath(),t.fillStyle="rgb(255, 163, 0)",t.strokeStyle="black",t.lineWidth=1,t.arc(16,16,15,0,2*Math.PI),t.stroke(),t.fill(),t.closePath()}).get()));const Xe=`

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );

  if ( isPerspective ) scale *= - mvPosition.z;

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( 0.0 ) * alignedPosition.x - sin( 0.0 ) * alignedPosition.y;
	rotatedPosition.y = sin( 0.0 ) * alignedPosition.x + cos( 0.0 ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,Ze=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class et extends F{constructor(){super(),this.vertexShader=Xe,this.fragmentShader=Ze,this.uniforms={color:{value:new x("white")}}}}class tt extends f{constructor(e){super(),r(this,"target"),r(this,"type","VisCSS2DPlaneHelper"),r(this,"observer"),this.geometry=new v(new w(1,1)),this.geometry.computeBoundingBox(),this.material=new et,this.scale.copy(e.matrixScale),this.position.set(e.position.x,e.position.y,e.position.z),this.target=e;const i=new MutationObserver(()=>{this.scale.copy(e.matrixScale)});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.position.set(this.target.position.x,this.target.position.y,this.target.position.z)},this.raycast=()=>{}}dispose(){this.observer.disconnect()}}class it extends f{constructor(e){super(),r(this,"target"),r(this,"type","VisCSS3DPlaneHelper"),r(this,"observer"),this.geometry=new v(new w(e.width,e.height)),this.geometry.computeBoundingBox(),this.material=M(),this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new v(new w(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const st=`
uniform float rotation2D;

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation2D ) * alignedPosition.x - sin( rotation2D ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation2D ) * alignedPosition.x + cos( rotation2D ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,rt=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class ot extends F{constructor(){super(),this.vertexShader=st,this.fragmentShader=rt,this.uniforms={color:{value:new x("white")},rotation2D:{value:0}}}}class at extends f{constructor(e){super(),r(this,"target"),r(this,"type","VisCSS3DSpriteHelper"),r(this,"observer"),this.geometry=new v(new w(1,1)),this.geometry.computeBoundingBox(),this.material=new ot,this.matrixAutoUpdate=!1,this.matrix=e.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=e.matrixWorld,this.target=e;const i=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new v(new w(e.width,e.height)),this.geometry.computeBoundingBox()});i.observe(e.element,{attributeFilter:["style"]}),this.observer=i,this.onBeforeRender=()=>{this.material.uniforms.rotation2D.value=this.target.rotation2D},this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const q=class extends Ge{constructor(t){super(),r(this,"target"),r(this,"type","VisGroupHelper"),this.target=t,this.geometry.computeBoundingBox(),this.material=new Le({map:q.colorTexture}),this.material.depthTest=!1,this.material.depthWrite=!1,this.scale.set(5,5,5);const e=this.updateMatrixWorld.bind(this);this.updateMatrixWorld=i=>{const s=this.position,o=this.target.position;s.x=o.x,s.y=o.y,s.z=o.z,e(i)}}raycast(t,e){const i=this.matrixWorld,s=this.geometry.boundingBox.clone();if(s.applyMatrix4(i),t.ray.intersectsBox(s)){const o=this.target;e.push({distance:t.ray.origin.distanceTo(o.position),object:o,point:o.position})}}};let J=q;r(J,"colorTexture",new R(new U({width:512,height:512}).draw(t=>{t.beginPath(),t.fillStyle="rgba(0, 0, 0, 0)",t.fillRect(0,0,512,512),t.closePath(),t.translate(256,200),t.beginPath(),t.fillStyle="yellow",t.fillRect(-200,0,400,200),t.closePath(),t.beginPath(),t.fillStyle="yellow",t.fillRect(-200,-70,200,70),t.closePath()}).get()));const Q=class extends L{constructor(t){super(),r(this,"target"),r(this,"cachaGeometryUUid"),r(this,"type","VisLineHelper"),this.target=t,this.geometry.dispose(),this.geometry.copy(t.geometry),this.cachaGeometryUUid=t.geometry.uuid,this.material=new O({color:"rgb(255, 255, 255)",alphaMap:Q.alphaTexture,transparent:!0,size:5,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this.renderOrder=-1,this.raycast=()=>{},this.onBeforeRender=()=>{const e=this.target;e.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=e.geometry.clone(),this.cachaGeometryUUid=e.geometry.uuid)}}};let X=Q;r(X,"alphaTexture",new R(new U({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(t=>{t.beginPath(),t.fillStyle="rgb(255, 255, 255)",t.arc(256,256,200,0,Math.PI*2),t.fill(),t.closePath()}).getDom()));class nt extends f{constructor(e){super(),r(this,"target"),r(this,"type","VisMeshHelper"),r(this,"cachaGeometryUUid");const i=1;this.target=e,this.geometry=new v(e.geometry,i),this.cachaGeometryUUid=e.geometry.uuid,this.material=M(),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.updateMatrixWorld=()=>{},this.raycast=()=>{},this.onBeforeRender=()=>{const s=this.target;s.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=new v(s.geometry,i),this.cachaGeometryUUid=s.geometry.uuid)}}}const Z=class extends L{constructor(t){super(),r(this,"target"),r(this,"type","VisPointsHelper"),this.target=t,this.geometry.dispose(),this.geometry.copy(t.geometry),this.material.dispose(),this.material=new O({color:"rgb(255, 255, 255)",alphaMap:Z.alphaTexture,transparent:!0});const e=Array.isArray(t.material)?t.material[0]:t.material;e instanceof O&&(this.material.size=e.size,this.material.sizeAttenuation=e.sizeAttenuation),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this.raycast=()=>{}}};let ee=Z;r(ee,"alphaTexture",new R(new U({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(t=>{t.beginPath(),t.strokeStyle="rgb(255, 255, 255)",t.lineWidth=4,t.strokeRect(0,0,512,512),t.closePath()}).get()));const lt=`

uniform float rotation;
uniform vec2 center;
uniform bool sizeAttenuation;

#include <common>

void main() {
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	if (!sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;
  }

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,ct=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class ht extends F{constructor(){super(),this.vertexShader=lt,this.fragmentShader=ct,this.uniforms={color:{value:new x("white")},center:{value:new Ve(.5,.5)},rotation:{value:0},sizeAttenuation:{value:!1}}}}class dt extends f{constructor(e){super(),r(this,"target"),r(this,"type","VisSpriteHelper"),this.geometry=new v(new w(1,1)),this.geometry.computeBoundingBox(),this.material=new ht,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=e.matrix,this.matrixWorld=e.matrixWorld,this.target=e,this.onBeforeRender=()=>{this.material.uniforms.rotation.value=this.target.material.rotation,this.material.uniforms.sizeAttenuation.value=this.target.material.sizeAttenuation},this.raycast=()=>{}}}class pt extends re{constructor(e={}){super(),r(this,"helperGenerator",{PointLight:Ye,SpotLight:Je,DirectionalLight:Ke,RectAreaLight:qe,PerspectiveCamera:I,OrthographicCamera:I,Mesh:nt,Group:J,Sprite:dt,Points:ee,Line:X,CSS3DPlane:it,CSS3DSprite:at,CSS2DPlane:tt}),r(this,"helperFilter",{AmbientLight:!0,HemisphereLight:!0,Object3D:!0,TransformControls:!0,Scene:!0}),r(this,"objectFilter",new Set),r(this,"objectHelperMap",new Map),e.helperGenerator&&(this.helperGenerator=Object.assign(this.helperGenerator,e.helperGenerator)),e.helperFilter&&(this.helperFilter=Object.assign(this.helperFilter,e.helperFilter)),e.objectFilter&&(this.objectFilter=new Set(e.objectFilter.concat(Array.from(this.objectFilter))))}addFilteredObject(...e){for(const i of e)this.objectFilter.add(i);return this}addObjectHelper(e){if(this.objectFilter.has(e)||this.objectHelperMap.has(e)||this.helperFilter[e.type]||e.type.toLocaleLowerCase().includes("helper"))return null;if(!this.helperGenerator[e.type])return console.warn(`object helper can not support this type object: '${e.type}'`),null;const i=new this.helperGenerator[e.type](e);return this.objectHelperMap.set(e,i),i}disposeObjectHelper(e){if(this.objectFilter.has(e)||this.helperFilter[e.type]||e.type.toLocaleLowerCase().includes("helper"))return null;if(!this.objectHelperMap.has(e))return console.warn("object helper manager can not found this object`s helper: ",e),null;const i=this.objectHelperMap.get(e);return i.geometry&&i.geometry.dispose(),i.material&&(i.material instanceof Ne?i.material.dispose():i.material.forEach(s=>{s.dispose()})),this.objectHelperMap.delete(e),i}dispose(){for(const e of this.objectHelperMap.keys())this.disposeObjectHelper(e);this.objectHelperMap.clear()}}const mt="@vis-three/plugin-object-helper",b="afterAdd",S="afterRemove";A.prototype.add=function(...t){if(!arguments.length)return this;if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.add(arguments[i]);return this}const e=t[0];if(e===this)return console.error("THREE.Object3D.add: object can't be added as a child of itself.",t),this;if(e&&e.isObject3D){if(e.parent!==null){const i=this.children.indexOf(e);i!==-1&&(e.parent=null,this.children.splice(i,1),e.dispatchEvent({type:"removed"}))}e.parent=this,this.children.push(e),e.dispatchEvent({type:"added"})}else console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",t);return this};const ut=A.prototype.add,gt=A.prototype.remove;A.prototype.add=function(...t){return ut.call(this,...t),this.dispatchEvent({type:b,objects:t}),this};A.prototype.remove=function(...t){return gt.call(this,...t),this.dispatchEvent({type:S,objects:t}),this};const te=T(mt),ft=function(){let t,e,i;const s=new WeakSet;return{name:te,install(o){const n=new pt,l=n.objectHelperMap;o.objectHelperManager=n,o.setObjectHelper=function(d){if(d)this.scene.traverse(a=>{l.has(a)&&this.scene.add(l.get(a))});else for(let a=0;a<this.scene.children.length;a++){const h=this.scene.children[a];l.has(h)&&this.scene.remove(l.get(h))}return this};const p=d=>{s.has(d)||(d.traverse(a=>{const h=n.addObjectHelper(a);h&&d.add(h)}),s.add(d))};e=d=>{const a=d.objects;for(const h of a){const m=n.addObjectHelper(h);!m||o.scene.add(m)}},i=d=>{const a=d.objects;for(const h of a){const m=n.disposeObjectHelper(h);!m||o.scene.remove(m)}},o.scene.addEventListener(b,e),o.scene.addEventListener(S,i),t=d=>{const a=d.scene;!s.has(a)&&p(a),a.hasEventListener(b,e)||a.addEventListener(b,e),a.hasEventListener(S,i)||a.addEventListener(S,i)},o.addEventListener(D.SETSCENE,t)},dispose(o){o.objectHelperManager.objectHelperMap.forEach(n=>{n.parent&&n.parent.remove(n)}),o.objectHelperManager.dispose(),delete o.objectHelperManager,delete o.setObjectHelper,o.removeEventListener(D.SETSCENE,t)}}},yt="@vis-three/strategy-trans-select-event",xt=T(yt),vt=function(){let t,e;return{name:xt,condition:[$,k,ye],exec(i){i.eventManager.addFilterObject(i.transformControls),t=s=>{if(i.transing){i.transing=!1;return}const o=s.intersections;if(s.ctrlKey||i.selectionBox.clear(),i.eventManager.penetrate)for(const n of o){if(s.ctrlKey&&i.selectionBox.has(n.object)){i.selectionBox.delete(n.object);continue}i.selectionBox.add(n.object)}else if(o.length){const n=o[0].object;if(s.ctrlKey&&i.selectionBox.has(n)){i.selectionBox.delete(n);return}i.selectionBox.add(n)}i.dispatchEvent({type:j,objects:Array.from(i.selectionBox)})},i.eventManager.addEventListener("click",t),e=s=>{i.transformControls.setAttach(...s.objects)},i.addEventListener(j,e)},rollback(i){i.eventManager.removeFilterObject(i.transformControls),i.eventManager.removeEventListener("click",t),i.eventManager.removeEventListener(j,e)}}},bt="@vis-three/strategy-helper-select-interact",St=T(bt),wt=function(t={}){const e=new Map,i=new Map,s=new Map,o=new Set;let n,l,p,d;return{name:St,condition:[k,te,$],exec(a){t.interact===void 0&&(t.interact=!0);const h=a.objectHelperManager,m=a.objectHelperManager.objectHelperMap;!t.activeColor&&(t.activeColor="rgb(230, 20, 240)"),!t.hoverColor&&(t.hoverColor="rgb(255, 158, 240)"),!t.defaultColor&&(t.defaultColor="rgb(255, 255, 255)"),!t.selectedColor&&(t.selectedColor=t.activeColor);const y=new x(t.defaultColor).getHex(),B=new x(t.activeColor).getHex(),ie=new x(t.hoverColor).getHex(),se=new x(t.selectedColor).getHex(),H=(g,u)=>{g.material.color?g.material.color.setHex(u):g.material instanceof F&&g.material.uniforms.color.value.setHex(u)};n=g=>{const u=g.objects;for(const c of u){const E=h.addObjectHelper(c);if(!!E&&(H(E,y),t.interact)){const V=()=>{a.transformControls.dragging||a.selectionBox&&a.selectionBox.has(c)||H(E,ie)},N=()=>{a.transformControls.dragging||a.selectionBox&&a.selectionBox.has(c)||H(E,y)},_=()=>{a.transformControls.dragging||a.selectionBox&&a.selectionBox.has(c)||H(E,B)};c.addEventListener("pointerenter",V),c.addEventListener("pointerleave",N),c.addEventListener("click",_),e.set(c,V),i.set(c,N),s.set(c,_)}}},l=g=>{const u=g.objects;for(const c of u)!h.disposeObjectHelper(c)||t.interact&&(c.removeEventListener("pointerenter",e.get(c)),c.removeEventListener("pointerleave",i.get(c)),c.removeEventListener("click",s.get(c)),e.delete(c),i.delete(c),s.delete(c))},a.scene.addEventListener(b,n),a.scene.addEventListener(S,l),p=g=>{const u=g.scene;u.hasEventListener(b,n)||u.addEventListener(b,n),u.hasEventListener(S,l)||u.addEventListener(S,l)},a.addEventListener(D.SETSCENE,p),d=g=>{o.forEach(u=>{H(u,y)}),o.clear();for(const u of g.objects)if(m.has(u)){const c=m.get(u);H(c,se),o.add(c)}},a.addEventListener(j,d)},rollback(a){a.scene.removeEventListener(b,n),a.scene.removeEventListener(S,l),a.removeEventListener(j,d),a.removeEventListener(D.SETSCENE,p),e.clear(),i.clear(),s.clear(),o.clear()}}};class Tt extends oe{constructor(){super(),this.install(ae()).install(ne({antialias:!0,alpha:!0})).install(_e()).install(pe()).install(le()).install(ce()).install(he({WebGLMultisampleRenderTarget:!0})).install(me()).install(fe()).install(xe()).install(ve()).install(je()).install(be()).install(Se()).install(we()).install(Me()).install(ft()),this.exec(ze()).exec(ue()).exec(de()).exec(ge()).exec(Pe()).exec(vt()).exec(He()).exec(Ee()).exec(Ce()).exec(wt()).exec(Ie())}}export{Tt as M};
