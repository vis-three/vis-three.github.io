import{b as I,S as k,d as $,n as C,i as _}from"./vis-three.tdcm.es.ba892fff.js";import{m as K}from"./curve.0ba3d968.js";import{a8 as c,J as p,K as y,c4 as X,I as Y,f as q,O as J,l as f,bv as m,bH as l,a4 as P,aL as W,w,M as Q,c5 as z,am as Z,aK as S,b as H,ag as A,a6 as v,c6 as j,bX as M,X as U,bt as tt,bs as et,V as it}from"./three.3f33d046.js";import{H as B}from"./vis-three.convenient.es.3345d486.js";const g=()=>new P({color:"rgb(255, 255, 255)"});class D extends c{constructor(t){super(),this.type="CameraHelper";const e=new p,s=[0,0,0,-1,1,-1,0,0,0,-1,1,1,0,0,0,-1,-1,-1,0,0,0,-1,-1,1,-1,-1,1,-1,-1,-1,-1,-1,-1,-1,1,-1,-1,1,-1,-1,1,1,-1,1,1,-1,-1,1,0,0,0,0,1,1,0,0,0,0,1,-1,0,0,0,0,-1,-1,0,0,0,0,-1,1,0,1,1,0,1,-1,0,1,-1,0,-1,-1,0,-1,-1,0,-1,1,0,-1,1,0,1,1,0,-1,1,2,-1,1,0,1,-1,2,1,-1,0,-1,-1,2,-1,-1,0,1,1,2,1,1,2,1,1,2,-1,1,2,-1,1,2,-1,-1,2,-1,-1,2,1,-1,2,1,-1,2,1,1];e.setAttribute("position",new y(s,3)),e.rotateY(-90*Math.PI/180),e.computeBoundingBox();const o=new X(t);o.matrix=new Y,o.matrixAutoUpdate=!0,o.raycast=()=>{},this.add(o),this.shape=o,this.geometry=e,this.material=g(),this.target=t,this.matrixAutoUpdate=!1,this.matrix=t.matrix,t instanceof q?this.cachaData={fov:t.fov,aspect:t.aspect,near:t.near,far:t.far}:t instanceof J?this.cachaData={left:t.left,right:t.right,top:t.top,bottom:t.bottom,near:t.near,far:t.far}:this.cachaData={},this.onBeforeRender=()=>{let r=!1;const a=this.cachaData;Object.keys(a).forEach(h=>{a[h]!==t[h]&&(a[h]=t[h],r=!0)}),r&&this.shape.update()}}raycast(t,e){const s=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(s),t.ray.intersectsBox(o)){const r=this.target;e.push({distance:t.ray.origin.distanceTo(r.position),object:r,point:r.position})}}dispose(){this.geometry.dispose(),this.material.dispose(),this.shape.dispose()}}class st extends c{constructor(t){super(),this.type="VisDirectionalLightHelper",this.geometry=new p;const e=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new y(e,3)),this.material=g(),this.geometry.boundingSphere;const s=new f().copy(t.color).multiplyScalar(t.intensity),o=new m(20,20);o.dispose();const r=new c(new l(o),new P({color:s}));r.raycast=()=>{},this.shape=r,this.target=t,this.sphere=new W(new w(0,0,0),1),this.cacheColor=t.color.getHex(),this.cacheVector3=new w,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=t.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=t.matrixWorld,this.onBeforeRender=()=>{const a=this.target,h=this.shape;a.color.getHex()!==this.cacheColor&&(h.material.color.copy(a.color).multiplyScalar(a.intensity),this.cacheColor=a.color.getHex()),h.lookAt(a.target.position)}}raycast(t,e){const s=this.target,o=s.matrixWorld,r=this.sphere;r.set(this.cacheVector3.set(0,0,0),1),r.applyMatrix4(o),t.ray.intersectsSphere(r)&&e.push({distance:t.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class ot extends c{constructor(t){super(),this.type="VisPointLightHelper",this.geometry=new p;const e=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new y(e,3)),this.material=g(),this.geometry.boundingSphere;const s=new f().copy(t.color).multiplyScalar(t.intensity),o=new Q(new z(t.distance,0),new Z({color:s,wireframe:!0}));o.raycast=()=>{},o.matrixAutoUpdate=!1,this.shape=o,this.target=t,this.sphere=new W(new w(0,0,0),1),this.cacheColor=t.color.getHex(),this.cacheDistance=t.distance,this.cacheVector3=new w,this.add(this.shape),this.matrixAutoUpdate=!1,this.matrix=t.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=t.matrixWorld,this.onBeforeRender=()=>{const r=this.target,a=this.shape;r.distance!==this.cacheDistance&&(a.geometry.dispose(),a.geometry=new z(r.distance,0),this.cacheDistance=r.distance),r.color.getHex()!==this.cacheColor&&(a.material.color.copy(r.color).multiplyScalar(r.intensity),this.cacheColor=r.color.getHex())}}raycast(t,e){const s=this.target,o=s.matrixWorld,r=this.sphere;r.set(this.cacheVector3.set(0,0,0),1),r.applyMatrix4(o),t.ray.intersectsSphere(r)&&e.push({distance:t.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}class rt extends c{constructor(t){super(),this.type="VisRectAreaLightHelper",this.cacheBox=new S,this.cacheVector3=new w,this.target=t,this.generateShape();const e=g();e.color.copy(t.color).multiplyScalar(t.intensity),this.cacheColor=t.color.getHex(),this.cacheIntensity=t.intensity,this.material=e,this.matrixAutoUpdate=!1,this.matrix=t.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=t.matrixWorld,this.onBeforeRender=()=>{const s=this.target;(s.width!==this.geometry.parameters.width||s.height!==this.geometry.parameters.height)&&this.generateShape(),(s.color.getHex()!==this.cacheColor||this.cacheIntensity!==s.intensity)&&(this.material.color.copy(s.color).multiplyScalar(s.intensity),this.cacheColor=s.color.getHex())}}generateShape(){this.geometry.dispose(),this.geometry=new m(this.target.width,this.target.height,4,4),this.geometry.computeBoundingBox()}raycast(t,e){const s=this.target,o=this.cacheBox;o.copy(this.geometry.boundingBox),o.applyMatrix4(s.matrixWorld),t.ray.intersectBox(o,this.cacheVector3)&&e.push({distance:t.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.geometry.dispose(),this.material.dispose()}}class at extends c{constructor(t){super(),this.type="VisSpotLightHelper",this.geometry=new p;const e=[-1,0,0,1,0,0,0,-1,0,0,1,0,0,0,-1,0,0,1,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,0,0,-.707,-.707,0,.707,.707,0,.707,-.707,0,-.707,.707,-.707,0,-.707,.707,0,.707,.707,0,-.707,-.707,0,.707];this.geometry.setAttribute("position",new y(e,3)),this.material=g(),this.geometry.boundingSphere;const s=new p,o=[0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let n=0,x=1,u=32;n<u;n++,x++){const b=n/u*Math.PI*2,O=x/u*Math.PI*2;o.push(Math.cos(b),Math.sin(b),1,Math.cos(O),Math.sin(O),1)}s.setAttribute("position",new y(o,3));const r=g(),a=new c(s,r);a.material.color.copy(t.color).multiplyScalar(t.intensity);const h=t.distance?t.distance:1e3,d=h*Math.tan(t.angle);a.scale.set(d,d,h),a.raycast=()=>{},this.add(a),this.matrixAutoUpdate=!1,this.matrix=t.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=t.matrixWorld,this.target=t,this.shape=a,this.sphere=new W(new w(0,0,0),1),this.cacheColor=t.color.getHex(),this.cacheDistance=t.distance,this.cacheAngle=t.angle,this.cacheVector3=new w,this.onBeforeRender=()=>{const n=this.target,x=this.shape;let u=!1;if(n.distance!==this.cacheDistance&&(this.cacheDistance=n.distance,x.scale.z=n.distance,u=!0),n.angle!==this.cacheAngle&&(this.cacheAngle=n.angle,u=!0),u){const b=n.distance*Math.tan(n.angle);x.scale.set(b,b,n.distance)}n.color.getHex()!==this.cacheColor&&(x.material.color.copy(n.color).multiplyScalar(n.intensity),this.cacheColor=n.color.getHex()),x.lookAt(n.target.position)}}raycast(t,e){const s=this.target,o=s.matrixWorld,r=this.sphere;r.set(this.cacheVector3.set(0,0,0),1),r.applyMatrix4(o),t.ray.intersectsSphere(r)&&e.push({distance:t.ray.origin.distanceTo(s.position),object:s,point:s.position})}dispose(){this.shape.geometry.dispose(),this.shape.material.dispose(),this.geometry.dispose(),this.material.dispose()}}const V=class R extends H{constructor(t){super(),this.type="GeometricOriginHelper",this.target=t,this.geometry=new p().setAttribute("position",new A(new Float32Array([0,0,0]),3)),this.material=new v({map:R.colorTexture,transparent:!0,alphaTest:.1,depthFunc:j,size:10,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}};V.colorTexture=new M(new B({width:32,height:32}).draw(i=>{i.beginPath(),i.fillStyle="rgba(0, 0, 0, 0)",i.fillRect(0,0,32,32),i.closePath(),i.beginPath(),i.fillStyle="rgb(255, 163, 0)",i.strokeStyle="black",i.lineWidth=1,i.arc(16,16,15,0,2*Math.PI),i.stroke(),i.fill(),i.closePath()}).get());let nt=V;class ht extends c{constructor(t){const e=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),s=new Float32Array(8*3),o=new p;o.setIndex(new A(e,1)),o.setAttribute("position",new A(s,3)),super(o,new P({color:15662848,toneMapped:!1})),this.type="BoundingBoxHelper",this.cacheBox=new S,this.compareBox=new S,this.matrixAutoUpdate=!1,this.raycast=()=>{},this.target=t,this.onBeforeRender=()=>{this.update()}}update(){if(this.cacheBox.setFromObject(this.target),this.cacheBox.isEmpty()||this.cacheBox.equals(this.compareBox))return;this.compareBox.copy(this.cacheBox);const t=this.cacheBox.min,e=this.cacheBox.max,s=this.geometry.attributes.position,o=s.array;o[0]=e.x,o[1]=e.y,o[2]=e.z,o[3]=t.x,o[4]=e.y,o[5]=e.z,o[6]=t.x,o[7]=t.y,o[8]=e.z,o[9]=e.x,o[10]=t.y,o[11]=e.z,o[12]=e.x,o[13]=e.y,o[14]=t.z,o[15]=t.x,o[16]=e.y,o[17]=t.z,o[18]=t.x,o[19]=t.y,o[20]=t.z,o[21]=e.x,o[22]=t.y,o[23]=t.z,s.needsUpdate=!0,this.geometry.computeBoundingSphere()}dispose(){}}class ct extends c{constructor(t){let e=5;if(t.geometry){const h=t.geometry;!h.boundingSphere&&h.computeBoundingSphere(),e=h.boundingSphere.radius*.8}const s=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],o=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],r=new p;r.setAttribute("position",new y(s,3)),r.setAttribute("color",new y(o,3));const a=new P({vertexColors:!0,toneMapped:!1,depthFunc:j});super(r,a),this.target=t,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this.renderOrder=100,this.raycast=()=>{}}dispose(){}}const lt=`

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

  bool isPerspective = isPerspectiveMatrix( projectionMatrix );

  if ( isPerspective ) scale *= - mvPosition.z;

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( 0.0 ) * alignedPosition.x - sin( 0.0 ) * alignedPosition.y;
	rotatedPosition.y = sin( 0.0 ) * alignedPosition.x + cos( 0.0 ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,dt=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;let pt=class extends U{constructor(){super(),this.vertexShader=lt,this.fragmentShader=dt,this.uniforms={color:{value:new f("white")}}}};class mt extends c{constructor(t){super(),this.type="VisCSS2DPlaneHelper",this.geometry=new l(new m(1,1)),this.geometry.computeBoundingBox(),this.material=new pt,this.scale.copy(t.matrixScale),this.position.set(t.position.x,t.position.y,t.position.z),this.target=t;const e=new MutationObserver(()=>{this.scale.copy(t.matrixScale)});e.observe(t.element,{attributeFilter:["style"]}),this.observer=e,this.onBeforeRender=()=>{this.position.set(this.target.position.x,this.target.position.y,this.target.position.z)},this.raycast=()=>{}}dispose(){this.observer.disconnect()}}class gt extends c{constructor(t){super(),this.type="VisCSS3DPlaneHelper",this.geometry=new l(new m(t.width,t.height)),this.geometry.computeBoundingBox(),this.material=g(),this.matrixAutoUpdate=!1,this.matrix=t.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=t.matrixWorld,this.target=t;const e=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new l(new m(t.width,t.height)),this.geometry.computeBoundingBox()});e.observe(t.element,{attributeFilter:["style"]}),this.observer=e,this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const xt=`
uniform float rotation2D;

#include <common>

void main() {
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	vec2 alignedPosition = position.xy * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation2D ) * alignedPosition.x - sin( rotation2D ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation2D ) * alignedPosition.x + cos( rotation2D ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,ut=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class yt extends U{constructor(){super(),this.vertexShader=xt,this.fragmentShader=ut,this.uniforms={color:{value:new f("white")},rotation2D:{value:0}}}}class wt extends c{constructor(t){super(),this.type="VisCSS3DSpriteHelper",this.geometry=new l(new m(1,1)),this.geometry.computeBoundingBox(),this.material=new yt,this.matrixAutoUpdate=!1,this.matrix=t.matrix,this.matrixWorldNeedsUpdate=!1,this.matrixWorld=t.matrixWorld,this.target=t;const e=new MutationObserver(()=>{this.geometry.dispose(),this.geometry=new l(new m(t.width,t.height)),this.geometry.computeBoundingBox()});e.observe(t.element,{attributeFilter:["style"]}),this.observer=e,this.onBeforeRender=()=>{this.material.uniforms.rotation2D.value=this.target.rotation2D},this.raycast=()=>{},this.updateMatrixWorld=()=>{}}dispose(){this.observer.disconnect()}}const T=class L extends tt{constructor(t){super(),this.type="VisGroupHelper",this.target=t,this.geometry.computeBoundingBox(),this.material=new et({map:L.colorTexture}),this.material.depthTest=!1,this.material.depthWrite=!1,this.scale.set(5,5,5);const e=this.updateMatrixWorld.bind(this);this.updateMatrixWorld=s=>{const o=this.position,r=this.target.position;o.x=r.x,o.y=r.y,o.z=r.z,e(s)}}raycast(t,e){const s=this.matrixWorld,o=this.geometry.boundingBox.clone();if(o.applyMatrix4(s),t.ray.intersectsBox(o)){const r=this.target;e.push({distance:t.ray.origin.distanceTo(r.position),object:r,point:r.position})}}dispose(){this.geometry.dispose(),this.material.dispose()}};T.colorTexture=new M(new B({width:512,height:512}).draw(i=>{i.beginPath(),i.fillStyle="rgba(0, 0, 0, 0)",i.fillRect(0,0,512,512),i.closePath(),i.translate(256,200),i.beginPath(),i.fillStyle="yellow",i.fillRect(-200,0,400,200),i.closePath(),i.beginPath(),i.fillStyle="yellow",i.fillRect(-200,-70,200,70),i.closePath()}).get());let bt=T;const F=class G extends H{constructor(t){super(),this.type="VisLineHelper",this.target=t,this.geometry.dispose(),this.geometry.copy(t.geometry),this.cachaGeometryUUid=t.geometry.uuid,this.material=new v({color:"rgb(255, 255, 255)",alphaMap:G.alphaTexture,transparent:!0,size:5,sizeAttenuation:!1}),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this.renderOrder=-1,this.raycast=()=>{},this.onBeforeRender=()=>{const e=this.target;e.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=e.geometry.clone(),this.cachaGeometryUUid=e.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}};F.alphaTexture=new M(new B({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(i=>{i.beginPath(),i.fillStyle="rgb(255, 255, 255)",i.arc(256,256,200,0,Math.PI*2),i.fill(),i.closePath()}).getDom());let ft=F;class vt extends c{constructor(t){super(),this.type="VisMeshHelper";const e=1;this.target=t,this.geometry=new l(t.geometry,e),this.cachaGeometryUUid=t.geometry.uuid,this.material=g(),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this.updateMatrixWorld=()=>{},this.raycast=()=>{},this.onBeforeRender=()=>{const s=this.target;s.geometry.uuid!==this.cachaGeometryUUid&&(this.geometry.dispose(),this.geometry=new l(s.geometry,e),this.cachaGeometryUUid=s.geometry.uuid)}}dispose(){this.geometry.dispose(),this.material.dispose()}}const E=class N extends H{constructor(t){super(),this.type="VisPointsHelper",this.target=t,this.geometry.dispose(),this.geometry.copy(t.geometry),this.material.dispose(),this.material=new v({color:"rgb(255, 255, 255)",alphaMap:N.alphaTexture,transparent:!0});const e=Array.isArray(t.material)?t.material[0]:t.material;e instanceof v&&(this.material.size=e.size,this.material.sizeAttenuation=e.sizeAttenuation),this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}};E.alphaTexture=new M(new B({width:512,height:512,bgColor:"rgb(0, 0, 0)"}).draw(i=>{i.beginPath(),i.strokeStyle="rgb(255, 255, 255)",i.lineWidth=4,i.strokeRect(0,0,512,512),i.closePath()}).get());let Pt=E;const Mt=`

uniform float rotation;
uniform vec2 center;
uniform bool sizeAttenuation;

#include <common>

void main() {
  vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );

	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

	if (!sizeAttenuation) {
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );

		if ( isPerspective ) scale *= - mvPosition.z;
  }

	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;

	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;

	mvPosition.xy += rotatedPosition;

	gl_Position = projectionMatrix * mvPosition;

}

`,Bt=`

uniform vec3 color;

void main() {
  gl_FragColor = vec4(color, 1.0);
}
`;class St extends U{constructor(){super(),this.vertexShader=Mt,this.fragmentShader=Bt,this.uniforms={color:{value:new f("white")},center:{value:new it(.5,.5)},rotation:{value:0},sizeAttenuation:{value:!1}}}}class At extends c{constructor(t){super(),this.type="VisSpriteHelper",this.geometry=new l(new m(1,1)),this.geometry.computeBoundingBox(),this.material=new St,this.matrixAutoUpdate=!1,this.matrixWorldNeedsUpdate=!1,this.matrix=t.matrix,this.matrixWorld=t.matrixWorld,this.target=t,this.onBeforeRender=()=>{this.material.uniforms.rotation.value=this.target.material.rotation,this.material.uniforms.sizeAttenuation.value=this.target.material.sizeAttenuation},this.raycast=()=>{}}dispose(){this.geometry.dispose(),this.material.dispose()}}const Wt=function(){return Object.assign(_(),{})},Ht=function(){return Object.assign(Wt(),{target:"",shape:!0,boundingBox:!1,geometricOrigin:!1,localAxes:!1})};class Ut extends K{constructor(){super(),this.shapeMap={PointLight:ot,SpotLight:at,DirectionalLight:st,RectAreaLight:rt,PerspectiveCamera:D,OrthographicCamera:D,Mesh:vt,Group:bt,Sprite:At,Points:Pt,Line:ft,CSS3DPlane:gt,CSS3DSprite:wt,CSS2DPlane:mt}}generateShape(){if(this.target){if(!this.shapeMap[this.target.type]){console.warn(`object helper can not support ${this.target.type}`);return}const t=new this.shapeMap[this.target.type](this.target);return this.shape=t,t}return null}generateBoundingBox(){if(this.target){const t=new ht(this.target);return this.boundingBox=t,t}return null}generateGeometricOrigin(){if(this.target){const t=new nt(this.target);return this.geometricOrigin=t,t}return null}generateLocalAxes(){if(this.target){const t=new ct(this.target);return this.localAxes=t,t}return null}dispose(t){if(t&&this[t]){this[t].removeFromParent(),this[t].dispose(),this[t]=void 0;return}this.target=void 0,["shape","boundingBox","geometricOrigin","localAxes"].forEach(e=>{this[e]&&(this[e].removeFromParent(),this[e].dispose(),this[e]=void 0)})}}const Ot=$({type:"ObjectHelper",config:Ht,context(){return{helperEventMap:{}}},shared:{addHelper(i,t,e,s){const o={shape:t.generateShape.bind(t),boundingBox:t.generateBoundingBox.bind(t),geometricOrigin:t.generateGeometricOrigin.bind(t),localAxes:t.generateLocalAxes.bind(t)};if(!o[i]){console.warn(`Object helper Model: can not found helper: ${i} in generator.`);return}const r=o[i]();s.toAsync(a=>{var h;const d=s.toObject(e.target);if(!d||!d.parent)return a&&console.warn(`object helper model can not fund object parent: ${d}`),!1;d.parent.add(r);const n=()=>{d.parent.add(r)};return(h=s.toModel(e.target))==null||h.on(`${C.COMPILED_ATTR}:parent`,n),s.helperEventMap[i]=n,!0})},removeHelper(i,t,e,s){var o;if(!s.toObject(e.target)){console.warn(`object helper model: can not fund object: ${e.target}`);return}const r=s.helperEventMap[i];r&&((o=s.toModel(e.target))==null||o.off(`${C.COMPILED_ATTR}:parent`,r)),t.dispose(i)}},commands:{set:{shape({model:i,config:t,target:e,value:s,engine:o}){s&&!e.shape?i.addHelper("shape",e,t,i):!s&&e.shape&&i.removeHelper("shape",e,t,i)},boundingBox({model:i,config:t,target:e,value:s,engine:o}){s&&!e.boundingBox?i.addHelper("boundingBox",e,t,i):!s&&e.boundingBox&&i.removeHelper("boundingBox",e,t,i)},geometricOrigin({model:i,config:t,target:e,value:s,engine:o}){s&&!e.geometricOrigin?i.addHelper("geometricOrigin",e,t,i):!s&&e.geometricOrigin&&i.removeHelper("geometricOrigin",e,t,i)},localAxes({model:i,config:t,target:e,value:s,engine:o}){s&&!e.localAxes?i.addHelper("localAxes",e,t,i):!s&&e.localAxes&&i.removeHelper("localAxes",e,t,i)}}},create({model:i,config:t,engine:e}){const s=new Ut;if(t.target){const o=e.getObjectBySymbol(t.target),r=e.getConfigBySymbol(t.target);r.helper=t.vid,o?(s.target=o,t.shape&&i.addHelper("shape",s,t,i),t.boundingBox&&i.addHelper("boundingBox",s,t,i),t.geometricOrigin&&i.addHelper("geometricOrigin",s,t,i),t.localAxes&&i.addHelper("localAxes",s,t,i)):console.warn(`object helper processor can not found target in engine ${t.target}`)}return s},dispose({target:i}){i.dispose()},expand:[{models:new RegExp("Mesh|Light|Line|Points|Group|Object3D"),config:()=>({helper:""}),commands:{add:{helper(){}},set:{helper(){}}}}]}),Vt=I({type:"helper",models:[Ot],lifeOrder:k.FOUR});export{At as M,D as N,Vt as O,at as a,bt as b,mt as d,vt as f,ft as j,gt as m,ot as o,rt as r,st as s,wt as y,Pt as z};
