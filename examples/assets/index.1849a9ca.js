import{t as se}from"./curve.0ba3d968.js";import{ag as ct,w as z,V as ut,br as $t,cc as O,cd as Ft,aL as ne,I as Pt,ce as ie,au as oe,aK as $,aa as Dt,a3 as re,a4 as ce,am as ae,G as le,J as Kt,M as fe}from"./three.3f33d046.js";import{m as ue}from"./vis-three.plugin-loader-manager.es.3fc670d5.js";const Jt=0,de=1,pe=2,Rt=2,Mt=1.25,Nt=1,At=6*4+4+4,Ct=65535,he=Math.pow(2,-24);class dt{constructor(){}}function U(i,t,e){return e.min.x=t[i],e.min.y=t[i+1],e.min.z=t[i+2],e.max.x=t[i+3],e.max.y=t[i+4],e.max.z=t[i+5],e}function qt(i){let t=-1,e=-1/0;for(let s=0;s<3;s++){const n=i[s+3]-i[s];n>e&&(e=n,t=s)}return t}function Ht(i,t){t.set(i)}function Ot(i,t,e){let s,n;for(let c=0;c<3;c++){const o=c+3;s=i[c],n=t[c],e[c]=s<n?s:n,s=i[o],n=t[o],e[o]=s>n?s:n}}function pt(i,t,e){for(let s=0;s<3;s++){const n=t[i+2*s],c=t[i+2*s+1],o=n-c,l=n+c;o<e[s]&&(e[s]=o),l>e[s+3]&&(e[s+3]=l)}}function nt(i){const t=i[3]-i[0],e=i[4]-i[1],s=i[5]-i[2];return 2*(t*e+e*s+s*t)}function ye(i,t){if(!i.index){const e=i.attributes.position.count,s=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;let n;e>65535?n=new Uint32Array(new s(4*e)):n=new Uint16Array(new s(2*e)),i.setIndex(new ct(n,1));for(let c=0;c<e;c++)n[c]=c}}function me(i){if(!i.groups||!i.groups.length)return[{offset:0,count:i.index.count/3}];const t=[],e=new Set;for(const n of i.groups)e.add(n.start),e.add(n.start+n.count);const s=Array.from(e.values()).sort((n,c)=>n-c);for(let n=0;n<s.length-1;n++){const c=s[n],o=s[n+1];t.push({offset:c/3,count:(o-c)/3})}return t}function St(i,t,e,s,n=null){let c=1/0,o=1/0,l=1/0,r=-1/0,f=-1/0,a=-1/0,d=1/0,u=1/0,h=1/0,x=-1/0,B=-1/0,A=-1/0;const p=n!==null;for(let m=t*6,y=(t+e)*6;m<y;m+=6){const b=i[m+0],g=i[m+1],w=b-g,P=b+g;w<c&&(c=w),P>r&&(r=P),p&&b<d&&(d=b),p&&b>x&&(x=b);const T=i[m+2],M=i[m+3],S=T-M,v=T+M;S<o&&(o=S),v>f&&(f=v),p&&T<u&&(u=T),p&&T>B&&(B=T);const I=i[m+4],F=i[m+5],C=I-F,V=I+F;C<l&&(l=C),V>a&&(a=V),p&&I<h&&(h=I),p&&I>A&&(A=I)}s[0]=c,s[1]=o,s[2]=l,s[3]=r,s[4]=f,s[5]=a,p&&(n[0]=d,n[1]=u,n[2]=h,n[3]=x,n[4]=B,n[5]=A)}function xe(i,t,e,s){let n=1/0,c=1/0,o=1/0,l=-1/0,r=-1/0,f=-1/0;for(let a=t*6,d=(t+e)*6;a<d;a+=6){const u=i[a+0];u<n&&(n=u),u>l&&(l=u);const h=i[a+2];h<c&&(c=h),h>r&&(r=h);const x=i[a+4];x<o&&(o=x),x>f&&(f=x)}s[0]=n,s[1]=c,s[2]=o,s[3]=l,s[4]=r,s[5]=f}function we(i,t,e,s,n){let c=e,o=e+s-1;const l=n.pos,r=n.axis*2;for(;;){for(;c<=o&&t[c*6+r]<l;)c++;for(;c<=o&&t[o*6+r]>=l;)o--;if(c<o){for(let f=0;f<3;f++){let a=i[c*3+f];i[c*3+f]=i[o*3+f],i[o*3+f]=a;let d=t[c*6+f*2+0];t[c*6+f*2+0]=t[o*6+f*2+0],t[o*6+f*2+0]=d;let u=t[c*6+f*2+1];t[c*6+f*2+1]=t[o*6+f*2+1],t[o*6+f*2+1]=u}c++,o--}else return c}}const H=32,be=(i,t)=>i.candidate-t.candidate,j=new Array(H).fill().map(()=>({count:0,bounds:new Float32Array(6),rightCacheBounds:new Float32Array(6),leftCacheBounds:new Float32Array(6),candidate:0})),ht=new Float32Array(6);function Ae(i,t,e,s,n,c){let o=-1,l=0;if(c===Jt)o=qt(t),o!==-1&&(l=(t[o]+t[o+3])/2);else if(c===de)o=qt(i),o!==-1&&(l=ge(e,s,n,o));else if(c===pe){const r=nt(i);let f=Mt*n;const a=s*6,d=(s+n)*6;for(let u=0;u<3;u++){const h=t[u],A=(t[u+3]-h)/H;if(n<H/4){const p=[...j];p.length=n;let m=0;for(let b=a;b<d;b+=6,m++){const g=p[m];g.candidate=e[b+2*u],g.count=0;const{bounds:w,leftCacheBounds:P,rightCacheBounds:T}=g;for(let M=0;M<3;M++)T[M]=1/0,T[M+3]=-1/0,P[M]=1/0,P[M+3]=-1/0,w[M]=1/0,w[M+3]=-1/0;pt(b,e,w)}p.sort(be);let y=n;for(let b=0;b<y;b++){const g=p[b];for(;b+1<y&&p[b+1].candidate===g.candidate;)p.splice(b+1,1),y--}for(let b=a;b<d;b+=6){const g=e[b+2*u];for(let w=0;w<y;w++){const P=p[w];g>=P.candidate?pt(b,e,P.rightCacheBounds):(pt(b,e,P.leftCacheBounds),P.count++)}}for(let b=0;b<y;b++){const g=p[b],w=g.count,P=n-g.count,T=g.leftCacheBounds,M=g.rightCacheBounds;let S=0;w!==0&&(S=nt(T)/r);let v=0;P!==0&&(v=nt(M)/r);const I=Nt+Mt*(S*w+v*P);I<f&&(o=u,f=I,l=g.candidate)}}else{for(let y=0;y<H;y++){const b=j[y];b.count=0,b.candidate=h+A+y*A;const g=b.bounds;for(let w=0;w<3;w++)g[w]=1/0,g[w+3]=-1/0}for(let y=a;y<d;y+=6){let w=~~((e[y+2*u]-h)/A);w>=H&&(w=H-1);const P=j[w];P.count++,pt(y,e,P.bounds)}const p=j[H-1];Ht(p.bounds,p.rightCacheBounds);for(let y=H-2;y>=0;y--){const b=j[y],g=j[y+1];Ot(b.bounds,g.rightCacheBounds,b.rightCacheBounds)}let m=0;for(let y=0;y<H-1;y++){const b=j[y],g=b.count,w=b.bounds,T=j[y+1].rightCacheBounds;g!==0&&(m===0?Ht(w,ht):Ot(w,ht,ht)),m+=g;let M=0,S=0;m!==0&&(M=nt(ht)/r);const v=n-m;v!==0&&(S=nt(T)/r);const I=Nt+Mt*(M*m+S*v);I<f&&(o=u,f=I,l=b.candidate)}}}}else console.warn(`MeshBVH: Invalid build strategy value ${c} used.`);return{axis:o,pos:l}}function ge(i,t,e,s){let n=0;for(let c=t,o=t+e;c<o;c++)n+=i[c*6+s*2];return n/e}function Pe(i,t){const e=i.attributes.position,s=i.index.array,n=s.length/3,c=new Float32Array(n*6),o=e.normalized,l=e.array,r=e.offset||0;let f=3;e.isInterleavedBufferAttribute&&(f=e.data.stride);const a=["getX","getY","getZ"];for(let d=0;d<n;d++){const u=d*3,h=d*6;let x,B,A;o?(x=s[u+0],B=s[u+1],A=s[u+2]):(x=s[u+0]*f+r,B=s[u+1]*f+r,A=s[u+2]*f+r);for(let p=0;p<3;p++){let m,y,b;o?(m=e[a[p]](x),y=e[a[p]](B),b=e[a[p]](A)):(m=l[x+p],y=l[B+p],b=l[A+p]);let g=m;y<g&&(g=y),b<g&&(g=b);let w=m;y>w&&(w=y),b>w&&(w=b);const P=(w-g)/2,T=p*2;c[h+T+0]=g+P,c[h+T+1]=P+(Math.abs(g)+P)*he,g<t[p]&&(t[p]=g),w>t[p+3]&&(t[p+3]=w)}}return c}function Be(i,t){function e(p){u&&u(p/h)}function s(p,m,y,b=null,g=0){if(!x&&g>=r&&(x=!0,f&&(console.warn(`MeshBVH: Max depth of ${r} reached when generating BVH. Consider increasing maxDepth.`),console.warn(i))),y<=a||g>=r)return e(m+y),p.offset=m,p.count=y,p;const w=Ae(p.boundingData,b,o,m,y,d);if(w.axis===-1)return e(m+y),p.offset=m,p.count=y,p;const P=we(l,o,m,y,w);if(P===m||P===m+y)e(m+y),p.offset=m,p.count=y;else{p.splitAxis=w.axis;const T=new dt,M=m,S=P-m;p.left=T,T.boundingData=new Float32Array(6),St(o,M,S,T.boundingData,c),s(T,M,S,c,g+1);const v=new dt,I=P,F=y-S;p.right=v,v.boundingData=new Float32Array(6),St(o,I,F,v.boundingData,c),s(v,I,F,c,g+1)}return p}ye(i,t);const n=new Float32Array(6),c=new Float32Array(6),o=Pe(i,n),l=i.index.array,r=t.maxDepth,f=t.verbose,a=t.maxLeafTris,d=t.strategy,u=t.onProgress,h=i.index.count/3;let x=!1;const B=[],A=me(i);if(A.length===1){const p=A[0],m=new dt;m.boundingData=n,xe(o,p.offset,p.count,c),s(m,p.offset,p.count,c),B.push(m)}else for(let p of A){const m=new dt;m.boundingData=new Float32Array(6),St(o,p.offset,p.count,m.boundingData,c),s(m,p.offset,p.count,c),B.push(m)}return B}function Te(i,t){const e=Be(i,t);let s,n,c;const o=[],l=t.useSharedArrayBuffer?SharedArrayBuffer:ArrayBuffer;for(let a=0;a<e.length;a++){const d=e[a];let u=r(d);const h=new l(At*u);s=new Float32Array(h),n=new Uint32Array(h),c=new Uint16Array(h),f(0,d),o.push(h)}return o;function r(a){return a.count?1:1+r(a.left)+r(a.right)}function f(a,d){const u=a/4,h=a/2,x=!!d.count,B=d.boundingData;for(let A=0;A<6;A++)s[u+A]=B[A];if(x){const A=d.offset,p=d.count;return n[u+6]=A,c[h+14]=p,c[h+15]=Ct,a+At}else{const A=d.left,p=d.right,m=d.splitAxis;let y;if(y=f(a+At,A),y/4>Math.pow(2,32))throw new Error("MeshBVH: Cannot store child pointer greater than 32 bits.");return n[u+6]=y/4,y=f(y,p),n[u+7]=m,y}}}class N{constructor(){this.min=1/0,this.max=-1/0}setFromPointsField(t,e){let s=1/0,n=-1/0;for(let c=0,o=t.length;c<o;c++){const r=t[c][e];s=r<s?r:s,n=r>n?r:n}this.min=s,this.max=n}setFromPoints(t,e){let s=1/0,n=-1/0;for(let c=0,o=e.length;c<o;c++){const l=e[c],r=t.dot(l);s=r<s?r:s,n=r>n?r:n}this.min=s,this.max=n}isSeparated(t){return this.min>t.max||t.min>this.max}}N.prototype.setFromBox=function(){const i=new z;return function(e,s){const n=s.min,c=s.max;let o=1/0,l=-1/0;for(let r=0;r<=1;r++)for(let f=0;f<=1;f++)for(let a=0;a<=1;a++){i.x=n.x*r+c.x*(1-r),i.y=n.y*f+c.y*(1-f),i.z=n.z*a+c.z*(1-a);const d=e.dot(i);o=Math.min(d,o),l=Math.max(d,l)}this.min=o,this.max=l}}();(function(){const i=new N;return function(e,s){const n=e.points,c=e.satAxes,o=e.satBounds,l=s.points,r=s.satAxes,f=s.satBounds;for(let a=0;a<3;a++){const d=o[a],u=c[a];if(i.setFromPoints(u,l),d.isSeparated(i))return!1}for(let a=0;a<3;a++){const d=f[a],u=r[a];if(i.setFromPoints(u,n),d.isSeparated(i))return!1}}})();const Me=function(){const i=new z,t=new z,e=new z;return function(n,c,o){const l=n.start,r=i,f=c.start,a=t;e.subVectors(l,f),i.subVectors(n.end,n.start),t.subVectors(c.end,c.start);const d=e.dot(a),u=a.dot(r),h=a.dot(a),x=e.dot(r),A=r.dot(r)*h-u*u;let p,m;A!==0?p=(d*u-x*h)/A:p=0,m=(d+p*u)/h,o.x=p,o.y=m}}(),Ut=function(){const i=new ut,t=new z,e=new z;return function(n,c,o,l){Me(n,c,i);let r=i.x,f=i.y;if(r>=0&&r<=1&&f>=0&&f<=1){n.at(r,o),c.at(f,l);return}else if(r>=0&&r<=1){f<0?c.at(0,l):c.at(1,l),n.closestPointToPoint(l,!0,o);return}else if(f>=0&&f<=1){r<0?n.at(0,o):n.at(1,o),c.closestPointToPoint(o,!0,l);return}else{let a;r<0?a=n.start:a=n.end;let d;f<0?d=c.start:d=c.end;const u=t,h=e;if(n.closestPointToPoint(d,!0,t),c.closestPointToPoint(a,!0,e),u.distanceToSquared(d)<=h.distanceToSquared(a)){o.copy(u),l.copy(d);return}else{o.copy(a),l.copy(h);return}}}}(),Se=function(){const i=new z,t=new z,e=new $t,s=new O;return function(c,o){const{radius:l,center:r}=c,{a:f,b:a,c:d}=o;if(s.start=f,s.end=a,s.closestPointToPoint(r,!0,i).distanceTo(r)<=l||(s.start=f,s.end=d,s.closestPointToPoint(r,!0,i).distanceTo(r)<=l)||(s.start=a,s.end=d,s.closestPointToPoint(r,!0,i).distanceTo(r)<=l))return!0;const B=o.getPlane(e);if(Math.abs(B.distanceToPoint(r))<=l){const p=B.projectPoint(r,t);if(o.containsPoint(p))return!0}return!1}}(),ve=1e-15;function K(i){return Math.abs(i)<ve}class k extends Ft{constructor(...t){super(...t),this.isExtendedTriangle=!0,this.satAxes=new Array(4).fill().map(()=>new z),this.satBounds=new Array(4).fill().map(()=>new N),this.points=[this.a,this.b,this.c],this.sphere=new ne,this.plane=new $t,this.needsUpdate=!0}intersectsSphere(t){return Se(t,this)}update(){const t=this.a,e=this.b,s=this.c,n=this.points,c=this.satAxes,o=this.satBounds,l=c[0],r=o[0];this.getNormal(l),r.setFromPoints(l,n);const f=c[1],a=o[1];f.subVectors(t,e),a.setFromPoints(f,n);const d=c[2],u=o[2];d.subVectors(e,s),u.setFromPoints(d,n);const h=c[3],x=o[3];h.subVectors(s,t),x.setFromPoints(h,n),this.sphere.setFromPoints(this.points),this.plane.setFromNormalAndCoplanarPoint(l,t),this.needsUpdate=!1}}k.prototype.closestPointToSegment=function(){const i=new z,t=new z,e=new O;return function(n,c=null,o=null){const{start:l,end:r}=n,f=this.points;let a,d=1/0;for(let u=0;u<3;u++){const h=(u+1)%3;e.start.copy(f[u]),e.end.copy(f[h]),Ut(e,n,i,t),a=i.distanceToSquared(t),a<d&&(d=a,c&&c.copy(i),o&&o.copy(t))}return this.closestPointToPoint(l,i),a=l.distanceToSquared(i),a<d&&(d=a,c&&c.copy(i),o&&o.copy(l)),this.closestPointToPoint(r,i),a=r.distanceToSquared(i),a<d&&(d=a,c&&c.copy(i),o&&o.copy(r)),Math.sqrt(d)}}();k.prototype.intersectsTriangle=function(){const i=new k,t=new Array(3),e=new Array(3),s=new N,n=new N,c=new z,o=new z,l=new z,r=new z,f=new O,a=new O,d=new O;return function(h,x=null,B=!1){this.needsUpdate&&this.update(),h.isExtendedTriangle?h.needsUpdate&&h.update():(i.copy(h),i.update(),h=i);const A=this.plane,p=h.plane;if(Math.abs(A.normal.dot(p.normal))>1-1e-10){const m=this.satBounds,y=this.satAxes;e[0]=h.a,e[1]=h.b,e[2]=h.c;for(let w=0;w<4;w++){const P=m[w],T=y[w];if(s.setFromPoints(T,e),P.isSeparated(s))return!1}const b=h.satBounds,g=h.satAxes;t[0]=this.a,t[1]=this.b,t[2]=this.c;for(let w=0;w<4;w++){const P=b[w],T=g[w];if(s.setFromPoints(T,t),P.isSeparated(s))return!1}for(let w=0;w<4;w++){const P=y[w];for(let T=0;T<4;T++){const M=g[T];if(c.crossVectors(P,M),s.setFromPoints(c,t),n.setFromPoints(c,e),s.isSeparated(n))return!1}}return x&&(B||console.warn("ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0."),x.start.set(0,0,0),x.end.set(0,0,0)),!0}else{const m=this.points;let y=!1,b=0;for(let C=0;C<3;C++){const V=m[C],E=m[(C+1)%3];f.start.copy(V),f.end.copy(E),f.delta(o);const L=y?a.start:a.end,_=K(p.distanceToPoint(V));if(K(p.normal.dot(o))&&_){a.copy(f),b=2;break}if((p.intersectLine(f,L)||_)&&!K(L.distanceTo(E))){if(b++,y)break;y=!0}}if(b===1&&h.containsPoint(a.end))return x&&(x.start.copy(a.end),x.end.copy(a.end)),!0;if(b!==2)return!1;const g=h.points;let w=!1,P=0;for(let C=0;C<3;C++){const V=g[C],E=g[(C+1)%3];f.start.copy(V),f.end.copy(E),f.delta(l);const L=w?d.start:d.end,_=K(A.distanceToPoint(V));if(K(A.normal.dot(l))&&_){d.copy(f),P=2;break}if((A.intersectLine(f,L)||_)&&!K(L.distanceTo(E))){if(P++,w)break;w=!0}}if(P===1&&this.containsPoint(d.end))return x&&(x.start.copy(d.end),x.end.copy(d.end)),!0;if(P!==2)return!1;if(a.delta(o),d.delta(l),o.dot(l)<0){let C=d.start;d.start=d.end,d.end=C}const T=a.start.dot(o),M=a.end.dot(o),S=d.start.dot(o),v=d.end.dot(o),I=M<S,F=T<v;return T!==v&&S!==M&&I===F?!1:(x&&(r.subVectors(a.start,d.start),r.dot(o)>0?x.start.copy(a.start):x.start.copy(d.start),r.subVectors(a.end,d.end),r.dot(o)<0?x.end.copy(a.end):x.end.copy(d.end)),!0)}}}();k.prototype.distanceToPoint=function(){const i=new z;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();k.prototype.distanceToTriangle=function(){const i=new z,t=new z,e=["a","b","c"],s=new O,n=new O;return function(o,l=null,r=null){const f=l||r?s:null;if(this.intersectsTriangle(o,f))return(l||r)&&(l&&f.getCenter(l),r&&f.getCenter(r)),0;let a=1/0;for(let d=0;d<3;d++){let u;const h=e[d],x=o[h];this.closestPointToPoint(x,i),u=x.distanceToSquared(i),u<a&&(a=u,l&&l.copy(i),r&&r.copy(x));const B=this[h];o.closestPointToPoint(B,i),u=B.distanceToSquared(i),u<a&&(a=u,l&&l.copy(B),r&&r.copy(i))}for(let d=0;d<3;d++){const u=e[d],h=e[(d+1)%3];s.set(this[u],this[h]);for(let x=0;x<3;x++){const B=e[x],A=e[(x+1)%3];n.set(o[B],o[A]),Ut(s,n,i,t);const p=i.distanceToSquared(t);p<a&&(a=p,l&&l.copy(i),r&&r.copy(t))}}return Math.sqrt(a)}}();class q{constructor(t,e,s){this.isOrientedBox=!0,this.min=new z,this.max=new z,this.matrix=new Pt,this.invMatrix=new Pt,this.points=new Array(8).fill().map(()=>new z),this.satAxes=new Array(3).fill().map(()=>new z),this.satBounds=new Array(3).fill().map(()=>new N),this.alignedSatBounds=new Array(3).fill().map(()=>new N),this.needsUpdate=!1,t&&this.min.copy(t),e&&this.max.copy(e),s&&this.matrix.copy(s)}set(t,e,s){this.min.copy(t),this.max.copy(e),this.matrix.copy(s),this.needsUpdate=!0}copy(t){this.min.copy(t.min),this.max.copy(t.max),this.matrix.copy(t.matrix),this.needsUpdate=!0}}q.prototype.update=function(){return function(){const t=this.matrix,e=this.min,s=this.max,n=this.points;for(let f=0;f<=1;f++)for(let a=0;a<=1;a++)for(let d=0;d<=1;d++){const u=1*f|2*a|4*d,h=n[u];h.x=f?s.x:e.x,h.y=a?s.y:e.y,h.z=d?s.z:e.z,h.applyMatrix4(t)}const c=this.satBounds,o=this.satAxes,l=n[0];for(let f=0;f<3;f++){const a=o[f],d=c[f],u=1<<f,h=n[u];a.subVectors(l,h),d.setFromPoints(a,n)}const r=this.alignedSatBounds;r[0].setFromPointsField(n,"x"),r[1].setFromPointsField(n,"y"),r[2].setFromPointsField(n,"z"),this.invMatrix.copy(this.matrix).invert(),this.needsUpdate=!1}}();q.prototype.intersectsBox=function(){const i=new N;return function(e){this.needsUpdate&&this.update();const s=e.min,n=e.max,c=this.satBounds,o=this.satAxes,l=this.alignedSatBounds;if(i.min=s.x,i.max=n.x,l[0].isSeparated(i)||(i.min=s.y,i.max=n.y,l[1].isSeparated(i))||(i.min=s.z,i.max=n.z,l[2].isSeparated(i)))return!1;for(let r=0;r<3;r++){const f=o[r],a=c[r];if(i.setFromBox(f,e),a.isSeparated(i))return!1}return!0}}();q.prototype.intersectsTriangle=function(){const i=new k,t=new Array(3),e=new N,s=new N,n=new z;return function(o){this.needsUpdate&&this.update(),o.isExtendedTriangle?o.needsUpdate&&o.update():(i.copy(o),i.update(),o=i);const l=this.satBounds,r=this.satAxes;t[0]=o.a,t[1]=o.b,t[2]=o.c;for(let u=0;u<3;u++){const h=l[u],x=r[u];if(e.setFromPoints(x,t),h.isSeparated(e))return!1}const f=o.satBounds,a=o.satAxes,d=this.points;for(let u=0;u<3;u++){const h=f[u],x=a[u];if(e.setFromPoints(x,d),h.isSeparated(e))return!1}for(let u=0;u<3;u++){const h=r[u];for(let x=0;x<4;x++){const B=a[x];if(n.crossVectors(h,B),e.setFromPoints(n,t),s.setFromPoints(n,d),e.isSeparated(s))return!1}}return!0}}();q.prototype.closestPointToPoint=function(){return function(t,e){return this.needsUpdate&&this.update(),e.copy(t).applyMatrix4(this.invMatrix).clamp(this.min,this.max).applyMatrix4(this.matrix),e}}();q.prototype.distanceToPoint=function(){const i=new z;return function(e){return this.closestPointToPoint(e,i),e.distanceTo(i)}}();q.prototype.distanceToBox=function(){const i=["x","y","z"],t=new Array(12).fill().map(()=>new O),e=new Array(12).fill().map(()=>new O),s=new z,n=new z;return function(o,l=0,r=null,f=null){if(this.needsUpdate&&this.update(),this.intersectsBox(o))return(r||f)&&(o.getCenter(n),this.closestPointToPoint(n,s),o.closestPointToPoint(s,n),r&&r.copy(s),f&&f.copy(n)),0;const a=l*l,d=o.min,u=o.max,h=this.points;let x=1/0;for(let A=0;A<8;A++){const p=h[A];n.copy(p).clamp(d,u);const m=p.distanceToSquared(n);if(m<x&&(x=m,r&&r.copy(p),f&&f.copy(n),m<a))return Math.sqrt(m)}let B=0;for(let A=0;A<3;A++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){const y=(A+1)%3,b=(A+2)%3,g=p<<y|m<<b,w=1<<A|p<<y|m<<b,P=h[g],T=h[w];t[B].set(P,T);const S=i[A],v=i[y],I=i[b],F=e[B],C=F.start,V=F.end;C[S]=d[S],C[v]=p?d[v]:u[v],C[I]=m?d[I]:u[v],V[S]=u[S],V[v]=p?d[v]:u[v],V[I]=m?d[I]:u[v],B++}for(let A=0;A<=1;A++)for(let p=0;p<=1;p++)for(let m=0;m<=1;m++){n.x=A?u.x:d.x,n.y=p?u.y:d.y,n.z=m?u.z:d.z,this.closestPointToPoint(n,s);const y=n.distanceToSquared(s);if(y<x&&(x=y,r&&r.copy(s),f&&f.copy(n),y<a))return Math.sqrt(y)}for(let A=0;A<12;A++){const p=t[A];for(let m=0;m<12;m++){const y=e[m];Ut(p,y,s,n);const b=s.distanceToSquared(n);if(b<x&&(x=b,r&&r.copy(s),f&&f.copy(n),b<a))return Math.sqrt(b)}}return Math.sqrt(x)}}();const yt=new z,mt=new z,xt=new z,kt=new ut,Xt=new ut,jt=new ut,Wt=new z;function Ie(i,t,e,s,n,c){let o;return c===ie?o=i.intersectTriangle(s,e,t,!0,n):o=i.intersectTriangle(t,e,s,c!==oe,n),o===null?null:{distance:i.origin.distanceTo(n),point:n.clone()}}function ze(i,t,e,s,n,c,o){yt.fromBufferAttribute(t,s),mt.fromBufferAttribute(t,n),xt.fromBufferAttribute(t,c);const l=Ie(i,yt,mt,xt,Wt,o);if(l){e&&(kt.fromBufferAttribute(e,s),Xt.fromBufferAttribute(e,n),jt.fromBufferAttribute(e,c),l.uv=Ft.getUV(Wt,yt,mt,xt,kt,Xt,jt,new ut));const r={a:s,b:n,c,normal:new z,materialIndex:0};Ft.getNormal(yt,mt,xt,r.normal),l.face=r,l.faceIndex=s}return l}function Qt(i,t,e,s,n){const c=s*3,o=i.index.getX(c),l=i.index.getX(c+1),r=i.index.getX(c+2),f=ze(e,i.attributes.position,i.attributes.uv,o,l,r,t);return f?(f.faceIndex=s,n&&n.push(f),f):null}function Fe(i,t,e,s,n,c){for(let o=s,l=s+n;o<l;o++)Qt(i,t,e,o,c)}function Ce(i,t,e,s,n){let c=1/0,o=null;for(let l=s,r=s+n;l<r;l++){const f=Qt(i,t,e,l);f&&f.distance<c&&(o=f,c=f.distance)}return o}function R(i,t,e,s){const n=i.a,c=i.b,o=i.c;let l=t,r=t+1,f=t+2;e&&(l=e.getX(t),r=e.getX(t+1),f=e.getX(t+2)),n.x=s.getX(l),n.y=s.getY(l),n.z=s.getZ(l),c.x=s.getX(r),c.y=s.getY(r),c.z=s.getZ(r),o.x=s.getX(f),o.y=s.getY(f),o.z=s.getZ(f)}function Yt(i,t,e,s,n,c,o){const l=e.index,r=e.attributes.position;for(let f=i,a=t+i;f<a;f++)if(R(o,f*3,l,r),o.needsUpdate=!0,s(o,f,n,c))return!0;return!1}class te{constructor(t){this._getNewPrimitive=t,this._primitives=[]}getPrimitive(){const t=this._primitives;return t.length===0?this._getNewPrimitive():t.pop()}releasePrimitive(t){this._primitives.push(t)}}function W(i,t){return t[i+15]===65535}function tt(i,t){return t[i+6]}function at(i,t){return t[i+14]}function lt(i){return i+8}function ft(i,t){return t[i+6]}function Ve(i,t){return t[i+7]}const Q=new $,Bt=new z,Le=["x","y","z"];function Vt(i,t,e,s,n){let c=i*2,o=st,l=Y,r=Z;if(W(c,l)){const a=tt(i,r),d=at(c,l);Fe(t,e,s,a,d,n)}else{const a=lt(i);Tt(a,o,s,Bt)&&Vt(a,t,e,s,n);const d=ft(i,r);Tt(d,o,s,Bt)&&Vt(d,t,e,s,n)}}function Lt(i,t,e,s){let n=i*2,c=st,o=Y,l=Z;if(W(n,o)){const f=tt(i,l),a=at(n,o);return Ce(t,e,s,f,a)}else{const f=Ve(i,l),a=Le[f],u=s.direction[a]>=0;let h,x;u?(h=lt(i),x=ft(i,l)):(h=ft(i,l),x=lt(i));const A=Tt(h,c,s,Bt)?Lt(h,t,e,s):null;if(A){const y=A.point[a];if(u?y<=c[x+f]:y>=c[x+f+3])return A}const m=Tt(x,c,s,Bt)?Lt(x,t,e,s):null;return A&&m?A.distance<=m.distance?A:m:A||m||null}}const Ee=function(){let i,t;const e=[],s=new te(()=>new $);return function(...o){i=s.getPrimitive(),t=s.getPrimitive(),e.push(i,t);const l=n(...o);s.releasePrimitive(i),s.releasePrimitive(t),e.pop(),e.pop();const r=e.length;return r>0&&(t=e[r-1],i=e[r-2]),l};function n(c,o,l,r,f=null,a=0,d=0){function u(y){let b=y*2,g=Y,w=Z;for(;!W(b,g);)y=lt(y),b=y*2;return tt(y,w)}function h(y){let b=y*2,g=Y,w=Z;for(;!W(b,g);)y=ft(y,w),b=y*2;return tt(y,w)+at(b,g)}let x=c*2,B=st,A=Y,p=Z;if(W(x,A)){const y=tt(c,p),b=at(x,A);return U(c,B,i),r(y,b,!1,d,a+c,i)}else{const y=lt(c),b=ft(c,p);let g=y,w=b,P,T,M,S;if(f&&(M=i,S=t,U(g,B,M),U(w,B,S),P=f(M),T=f(S),T<P)){g=b,w=y;const L=P;P=T,T=L,M=S}M||(M=i,U(g,B,M));const v=W(g*2,A),I=l(M,v,P,d+1,a+g);let F;if(I===Rt){const L=u(g),X=h(g)-L;F=r(L,X,!0,d+1,a+g,M)}else F=I&&n(g,o,l,r,f,a,d+1);if(F)return!0;S=t,U(w,B,S);const C=W(w*2,A),V=l(S,C,T,d+1,a+w);let E;if(V===Rt){const L=u(w),X=h(w)-L;E=r(L,X,!0,d+1,a+w,S)}else E=V&&n(w,o,l,r,f,a,d+1);return!!E}}}(),Ue=function(){const i=new k,t=new k,e=new Pt,s=new q,n=new q;return function c(o,l,r,f,a=null){let d=o*2,u=st,h=Y,x=Z;if(a===null&&(r.boundingBox||r.computeBoundingBox(),s.set(r.boundingBox.min,r.boundingBox.max,f),a=s),W(d,h)){const A=l,p=A.index,m=A.attributes.position,y=r.index,b=r.attributes.position,g=tt(o,x),w=at(d,h);if(e.copy(f).invert(),r.boundsTree)return U(o,u,n),n.matrix.copy(e),n.needsUpdate=!0,r.boundsTree.shapecast({intersectsBounds:T=>n.intersectsBox(T),intersectsTriangle:T=>{T.a.applyMatrix4(f),T.b.applyMatrix4(f),T.c.applyMatrix4(f),T.needsUpdate=!0;for(let M=g*3,S=(w+g)*3;M<S;M+=3)if(R(t,M,p,m),t.needsUpdate=!0,T.intersectsTriangle(t))return!0;return!1}});for(let P=g*3,T=w+g*3;P<T;P+=3){R(i,P,p,m),i.a.applyMatrix4(e),i.b.applyMatrix4(e),i.c.applyMatrix4(e),i.needsUpdate=!0;for(let M=0,S=y.count;M<S;M+=3)if(R(t,M,y,b),t.needsUpdate=!0,i.intersectsTriangle(t))return!0}}else{const A=o+8,p=x[o+6];return U(A,u,Q),!!(a.intersectsBox(Q)&&c(A,l,r,f,a)||(U(p,u,Q),a.intersectsBox(Q)&&c(p,l,r,f,a)))}}}();function Tt(i,t,e,s){return U(i,t,Q),e.intersectBox(Q,s)}const Et=[];let gt,st,Y,Z;function rt(i){gt&&Et.push(gt),gt=i,st=new Float32Array(i),Y=new Uint16Array(i),Z=new Uint32Array(i)}function wt(){gt=null,st=null,Y=null,Z=null,Et.length&&rt(Et.pop())}const vt=Symbol("skip tree generation"),It=new $,zt=new $,J=new Pt,G=new q,it=new q,ot=new z,bt=new z,_e=new z,De=new z,Re=new z,Zt=new $,D=new te(()=>new k);class et{static serialize(t,e={}){if(e.isBufferGeometry)return console.warn("MeshBVH.serialize: The arguments for the function have changed. See documentation for new signature."),et.serialize(arguments[0],{cloneBuffers:arguments[2]===void 0?!0:arguments[2]});e={cloneBuffers:!0,...e};const s=t.geometry,n=t._roots,c=s.getIndex();let o;return e.cloneBuffers?o={roots:n.map(l=>l.slice()),index:c.array.slice()}:o={roots:n,index:c.array},o}static deserialize(t,e,s={}){if(typeof s=="boolean")return console.warn("MeshBVH.deserialize: The arguments for the function have changed. See documentation for new signature."),et.deserialize(arguments[0],arguments[1],{setIndex:arguments[2]===void 0?!0:arguments[2]});s={setIndex:!0,...s};const{index:n,roots:c}=t,o=new et(e,{...s,[vt]:!0});if(o._roots=c,s.setIndex){const l=e.getIndex();if(l===null){const r=new ct(t.index,1,!1);e.setIndex(r)}else l.array!==n&&(l.array.set(n),l.needsUpdate=!0)}return o}constructor(t,e={}){if(t.isBufferGeometry){if(t.index&&t.index.isInterleavedBufferAttribute)throw new Error("MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.")}else throw new Error("MeshBVH: Only BufferGeometries are supported.");if(e=Object.assign({strategy:Jt,maxDepth:40,maxLeafTris:10,verbose:!0,useSharedArrayBuffer:!1,setBoundingBox:!0,onProgress:null,[vt]:!1},e),e.useSharedArrayBuffer&&typeof SharedArrayBuffer=="undefined")throw new Error("MeshBVH: SharedArrayBuffer is not available.");this._roots=null,e[vt]||(this._roots=Te(t,e),!t.boundingBox&&e.setBoundingBox&&(t.boundingBox=this.getBoundingBox(new $))),this.geometry=t}refit(t=null){t&&Array.isArray(t)&&(t=new Set(t));const e=this.geometry,s=e.index.array,n=e.attributes.position;let c,o,l,r,f=0;const a=this._roots;for(let u=0,h=a.length;u<h;u++)c=a[u],o=new Uint32Array(c),l=new Uint16Array(c),r=new Float32Array(c),d(0,f),f+=c.byteLength;function d(u,h,x=!1){const B=u*2;if(l[B+15]===Ct){const p=o[u+6],m=l[B+14];let y=1/0,b=1/0,g=1/0,w=-1/0,P=-1/0,T=-1/0;for(let M=3*p,S=3*(p+m);M<S;M++){const v=s[M],I=n.getX(v),F=n.getY(v),C=n.getZ(v);I<y&&(y=I),I>w&&(w=I),F<b&&(b=F),F>P&&(P=F),C<g&&(g=C),C>T&&(T=C)}return r[u+0]!==y||r[u+1]!==b||r[u+2]!==g||r[u+3]!==w||r[u+4]!==P||r[u+5]!==T?(r[u+0]=y,r[u+1]=b,r[u+2]=g,r[u+3]=w,r[u+4]=P,r[u+5]=T,!0):!1}else{const p=u+8,m=o[u+6],y=p+h,b=m+h;let g=x,w=!1,P=!1;t?g||(w=t.has(y),P=t.has(b),g=!w&&!P):(w=!0,P=!0);const T=g||w,M=g||P;let S=!1;T&&(S=d(p,h,g));let v=!1;M&&(v=d(m,h,g));const I=S||v;if(I)for(let F=0;F<3;F++){const C=p+F,V=m+F,E=r[C],L=r[C+3],_=r[V],X=r[V+3];r[u+F]=E<_?E:_,r[u+F+3]=L>X?L:X}return I}}}traverse(t,e=0){const s=this._roots[e],n=new Uint32Array(s),c=new Uint16Array(s);o(0);function o(l,r=0){const f=l*2,a=c[f+15]===Ct;if(a){const d=n[l+6],u=c[f+14];t(r,a,new Float32Array(s,l*4,6),d,u)}else{const d=l+At/4,u=n[l+6],h=n[l+7];t(r,a,new Float32Array(s,l*4,6),h)||(o(d,r+1),o(u,r+1))}}}raycast(t,e=Dt){const s=this._roots,n=this.geometry,c=[],o=e.isMaterial,l=Array.isArray(e),r=n.groups,f=o?e.side:e;for(let a=0,d=s.length;a<d;a++){const u=l?e[r[a].materialIndex].side:f,h=c.length;if(rt(s[a]),Vt(0,n,u,t,c),wt(),l){const x=r[a].materialIndex;for(let B=h,A=c.length;B<A;B++)c[B].face.materialIndex=x}}return c}raycastFirst(t,e=Dt){const s=this._roots,n=this.geometry,c=e.isMaterial,o=Array.isArray(e);let l=null;const r=n.groups,f=c?e.side:e;for(let a=0,d=s.length;a<d;a++){const u=o?e[r[a].materialIndex].side:f;rt(s[a]);const h=Lt(0,n,u,t);wt(),h!=null&&(l==null||h.distance<l.distance)&&(l=h,o&&(h.face.materialIndex=r[a].materialIndex))}return l}intersectsGeometry(t,e){const s=this.geometry;let n=!1;for(const c of this._roots)if(rt(c),n=Ue(0,s,t,e),wt(),n)break;return n}shapecast(t,e,s){const n=this.geometry;if(t instanceof Function){if(e){const u=e;e=(h,x,B,A)=>{const p=x*3;return u(h,p,p+1,p+2,B,A)}}t={boundsTraverseOrder:s,intersectsBounds:t,intersectsTriangle:e,intersectsRange:null},console.warn("MeshBVH: Shapecast function signature has changed and now takes an object of callbacks as a second argument. See docs for new signature.")}const c=D.getPrimitive();let{boundsTraverseOrder:o,intersectsBounds:l,intersectsRange:r,intersectsTriangle:f}=t;if(r&&f){const u=r;r=(h,x,B,A,p)=>u(h,x,B,A,p)?!0:Yt(h,x,n,f,B,A,c)}else r||(f?r=(u,h,x,B)=>Yt(u,h,n,f,x,B,c):r=(u,h,x)=>x);let a=!1,d=0;for(const u of this._roots){if(rt(u),a=Ee(0,n,l,r,o,d),wt(),a)break;d+=u.byteLength}return D.releasePrimitive(c),a}bvhcast(t,e,s){let{intersectsRanges:n,intersectsTriangles:c}=s;const o=this.geometry.index,l=this.geometry.attributes.position,r=t.geometry.index,f=t.geometry.attributes.position;J.copy(e).invert();const a=D.getPrimitive(),d=D.getPrimitive();if(c){let h=function(x,B,A,p,m,y,b,g){for(let w=A,P=A+p;w<P;w++){R(d,w*3,r,f),d.a.applyMatrix4(e),d.b.applyMatrix4(e),d.c.applyMatrix4(e),d.needsUpdate=!0;for(let T=x,M=x+B;T<M;T++)if(R(a,T*3,o,l),a.needsUpdate=!0,c(a,d,T,w,m,y,b,g))return!0}return!1};if(n){const x=n;n=function(B,A,p,m,y,b,g,w){return x(B,A,p,m,y,b,g,w)?!0:h(B,A,p,m,y,b,g,w)}}else n=h}t.getBoundingBox(zt),zt.applyMatrix4(e);const u=this.shapecast({intersectsBounds:h=>zt.intersectsBox(h),intersectsRange:(h,x,B,A,p,m)=>(It.copy(m),It.applyMatrix4(J),t.shapecast({intersectsBounds:y=>It.intersectsBox(y),intersectsRange:(y,b,g,w,P)=>n(h,x,y,b,A,p,w,P)}))});return D.releasePrimitive(a),D.releasePrimitive(d),u}intersectsBox(t,e){return G.set(t.min,t.max,e),G.needsUpdate=!0,this.shapecast({intersectsBounds:s=>G.intersectsBox(s),intersectsTriangle:s=>G.intersectsTriangle(s)})}intersectsSphere(t){return this.shapecast({intersectsBounds:e=>t.intersectsBox(e),intersectsTriangle:e=>e.intersectsSphere(t)})}closestPointToGeometry(t,e,s={},n={},c=0,o=1/0){t.boundingBox||t.computeBoundingBox(),G.set(t.boundingBox.min,t.boundingBox.max,e),G.needsUpdate=!0;const l=this.geometry,r=l.attributes.position,f=l.index,a=t.attributes.position,d=t.index,u=D.getPrimitive(),h=D.getPrimitive();let x=bt,B=_e,A=null,p=null;n&&(A=De,p=Re);let m=1/0,y=null,b=null;return J.copy(e).invert(),it.matrix.copy(J),this.shapecast({boundsTraverseOrder:g=>G.distanceToBox(g),intersectsBounds:(g,w,P)=>P<m&&P<o?(w&&(it.min.copy(g.min),it.max.copy(g.max),it.needsUpdate=!0),!0):!1,intersectsRange:(g,w)=>{if(t.boundsTree)return t.boundsTree.shapecast({boundsTraverseOrder:P=>it.distanceToBox(P),intersectsBounds:(P,T,M)=>M<m&&M<o,intersectsRange:(P,T)=>{for(let M=P*3,S=(P+T)*3;M<S;M+=3){R(h,M,d,a),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let v=g*3,I=(g+w)*3;v<I;v+=3){R(u,v,f,r),u.needsUpdate=!0;const F=u.distanceToTriangle(h,x,A);if(F<m&&(B.copy(x),p&&p.copy(A),m=F,y=v/3,b=M/3),F<c)return!0}}}});{const P=d?d.count:a.count;for(let T=0,M=P;T<M;T+=3){R(h,T,d,a),h.a.applyMatrix4(e),h.b.applyMatrix4(e),h.c.applyMatrix4(e),h.needsUpdate=!0;for(let S=g*3,v=(g+w)*3;S<v;S+=3){R(u,S,f,r),u.needsUpdate=!0;const I=u.distanceToTriangle(h,x,A);if(I<m&&(B.copy(x),p&&p.copy(A),m=I,y=S/3,b=T/3),I<c)return!0}}}}}),D.releasePrimitive(u),D.releasePrimitive(h),m===1/0?null:(s.point?s.point.copy(B):s.point=B.clone(),s.distance=m,s.faceIndex=y,n&&(n.point?n.point.copy(p):n.point=p.clone(),n.point.applyMatrix4(J),B.applyMatrix4(J),n.distance=B.sub(n.point).length(),n.faceIndex=b),s)}closestPointToPoint(t,e={},s=0,n=1/0){const c=s*s,o=n*n;let l=1/0,r=null;if(this.shapecast({boundsTraverseOrder:a=>(ot.copy(t).clamp(a.min,a.max),ot.distanceToSquared(t)),intersectsBounds:(a,d,u)=>u<l&&u<o,intersectsTriangle:(a,d)=>{a.closestPointToPoint(t,ot);const u=t.distanceToSquared(ot);return u<l&&(bt.copy(ot),l=u,r=d),u<c}}),l===1/0)return null;const f=Math.sqrt(l);return e.point?e.point.copy(bt):e.point=bt.clone(),e.distance=f,e.faceIndex=r,e}getBoundingBox(t){return t.makeEmpty(),this._roots.forEach(s=>{U(0,new Float32Array(s),Zt),t.union(Zt)}),t}}const Gt=new $;class Ne extends le{get isMesh(){return!this.displayEdges}get isLineSegments(){return this.displayEdges}get isLine(){return this.displayEdges}constructor(t,e,s=10,n=0){super(),this.material=e,this.geometry=new Kt,this.name="MeshBVHRootVisualizer",this.depth=s,this.displayParents=!1,this.mesh=t,this.displayEdges=!0,this._group=n}raycast(){}update(){const t=this.geometry,e=this.mesh.geometry.boundsTree,s=this._group;if(t.dispose(),this.visible=!1,e){const n=this.depth-1,c=this.displayParents;let o=0;e.traverse((u,h)=>{if(u===n||h)return o++,!0;c&&o++},s);let l=0;const r=new Float32Array(8*3*o);e.traverse((u,h,x)=>{const B=u===n||h;if(B||c){U(0,x,Gt);const{min:A,max:p}=Gt;for(let m=-1;m<=1;m+=2){const y=m<0?A.x:p.x;for(let b=-1;b<=1;b+=2){const g=b<0?A.y:p.y;for(let w=-1;w<=1;w+=2){const P=w<0?A.z:p.z;r[l+0]=y,r[l+1]=g,r[l+2]=P,l+=3}}}return B}},s);let f,a;this.displayEdges?a=new Uint8Array([0,4,1,5,2,6,3,7,0,2,1,3,4,6,5,7,0,1,2,3,4,5,6,7]):a=new Uint8Array([0,1,2,2,1,3,4,6,5,6,7,5,1,4,5,0,4,1,2,3,6,3,7,6,0,2,4,2,6,4,1,5,3,3,5,7]),r.length>65535?f=new Uint32Array(a.length*o):f=new Uint16Array(a.length*o);const d=a.length;for(let u=0;u<o;u++){const h=u*8,x=u*d;for(let B=0;B<d;B++)f[x+B]=h+a[B]}t.setIndex(new ct(f,1,!1)),t.setAttribute("position",new ct(r,3,!1)),this.visible=!0}}}class _t extends re{get color(){return this.edgeMaterial.color}get opacity(){return this.edgeMaterial.opacity}set opacity(t){this.edgeMaterial.opacity=t,this.meshMaterial.opacity=t}constructor(t,e=10){super(),this.name="MeshBVHVisualizer",this.depth=e,this.mesh=t,this.displayParents=!1,this.displayEdges=!0,this._roots=[];const s=new ce({color:65416,transparent:!0,opacity:.3,depthWrite:!1}),n=new ae({color:65416,transparent:!0,opacity:.3,depthWrite:!1});n.color=s.color,this.edgeMaterial=s,this.meshMaterial=n,this.update()}update(){const t=this.mesh.geometry.boundsTree,e=t?t._roots.length:0;for(;this._roots.length>e;){const s=this._roots.pop();s.geometry.dispose(),this.remove(s)}for(let s=0;s<e;s++){if(s>=this._roots.length){const c=new Ne(this.mesh,this.edgeMaterial,this.depth,s);this.add(c),this._roots.push(c)}const n=this._roots[s];n.depth=this.depth,n.mesh=this.mesh,n.displayParents=this.displayParents,n.displayEdges=this.displayEdges,n.material=this.displayEdges?this.edgeMaterial:this.meshMaterial,n.update()}}updateMatrixWorld(...t){this.position.copy(this.mesh.position),this.rotation.copy(this.mesh.rotation),this.scale.copy(this.mesh.scale),super.updateMatrixWorld(...t)}copy(t){this.depth=t.depth,this.mesh=t.mesh}clone(){return new _t(this.mesh,this.depth)}dispose(){this.edgeMaterial.dispose(),this.meshMaterial.dispose();const t=this.children;for(let e=0,s=t.length;e<s;e++)t[e].geometry.dispose()}}const ee=new Kt;ee.setAttribute("position",new ct(new Float32Array([0,0,0,0,0,0,0,0,0]),3));class qe{constructor(){this.bvh=new et(ee),this.castOptions={intersectsBounds:t=>!1,intersectsTriangle:()=>{}}}addBVH(t){const e=t.geometry.clone();e.applyMatrix4(t.matrixWorld);for(const s in e.attributes)s!=="position"&&e.deleteAttribute(s);this.bvh=new et(ue([this.bvh.geometry,e])),this.bvh.geometry.boundsTree=this.bvh,this.visualizer&&(this.visualizer.mesh.geometry=this.bvh.geometry,this.visualizer.update())}createVisualizer(){return this.visualizer=new _t(new fe(this.bvh.geometry)),this}shapecast(t){return this.bvh.shapecast(t||this.castOptions)}dispose(){var t;(t=this.visualizer)==null||t.dispose(),this.bvh.geometry.dispose()}}const He="@vis-three/plugin-mesh-bvh",Oe=se(He),We=function(i={}){return{name:Oe,install(t){const e=new qe;i.visualizer&&(e.createVisualizer(),t.scene.add(e.visualizer)),i.shapecast&&(e.castOptions=i.shapecast),t.meshBVHManager=e,t.addBVH=function(s){return e.addBVH(s),t}},dispose(t){t.meshBVHManager.dispose(),delete t.meshBVHManager,delete t.addBVH}}};export{We as M};
