import{w as O,J as G,ag as N,I as K,aS as W,M as q}from"./three.3f33d046.js";class B{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y,this.array[this.top++]=t.z}}class E{constructor(t){this.top=0,this.array=new Float32Array(t)}write(t){this.array[this.top++]=t.x,this.array[this.top++]=t.y}}class v{constructor(t){this.plane=null,this.front=null,this.back=null,this.polygons=[],t&&this.build(t)}clone(){const t=new v;return t.plane=this.plane&&this.plane.clone(),t.front=this.front&&this.front.clone(),t.back=this.back&&this.back.clone(),t.polygons=this.polygons.map(s=>s.clone()),t}invert(){for(let s=0;s<this.polygons.length;s++)this.polygons[s].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();const t=this.front;this.front=this.back,this.back=t}clipPolygons(t){if(!this.plane)return t.slice();let s=new Array,o=new Array;for(let e=0;e<t.length;e++)this.plane.splitPolygon(t[e],s,o,s,o);return this.front&&(s=this.front.clipPolygons(s)),this.back?o=this.back.clipPolygons(o):o=[],s.concat(o)}clipTo(t){this.polygons=t.clipPolygons(this.polygons),this.front&&this.front.clipTo(t),this.back&&this.back.clipTo(t)}allPolygons(){let t=this.polygons.slice();return this.front&&(t=t.concat(this.front.allPolygons())),this.back&&(t=t.concat(this.back.allPolygons())),t}build(t){if(!t.length)return;this.plane||(this.plane=t[0].plane.clone());const s=[],o=[];for(let e=0;e<t.length;e++)this.plane.splitPolygon(t[e],this.polygons,this.polygons,s,o);s.length&&(this.front||(this.front=new v),this.front.build(s)),o.length&&(this.back||(this.back=new v),this.back.build(o))}}class d{constructor(t=0,s=0,o=0){this.x=t,this.y=s,this.z=o}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}clone(){return new d(this.x,this.y,this.z)}negate(){return this.x*=-1,this.y*=-1,this.z*=-1,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}times(t){return this.x*=t,this.y*=t,this.z*=t,this}dividedBy(t){return this.x/=t,this.y/=t,this.z/=t,this}lerp(t,s){return this.add(new d().copy(t).sub(this).times(s))}unit(){return this.dividedBy(this.length())}length(){return Math.sqrt(Math.pow(this.x,2)+Math.pow(this.y,2)+Math.pow(this.z,2))}normalize(){return this.unit()}cross(t){const s=this.clone(),o=s.x,e=s.y,i=s.z,l=t.x,m=t.y,u=t.z;return this.x=e*u-i*m,this.y=i*l-o*u,this.z=o*m-e*l,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}toVector3(){return new O(this.x,this.y,this.z)}}class x{constructor(t,s){this.normal=t,this.w=s,this.normal=t,this.w=s}clone(){return new x(this.normal.clone(),this.w)}flip(){this.normal.negate(),this.w=-this.w}splitPolygon(t,s,o,e,i){let f=0;const p=[];for(let g=0;g<t.vertices.length;g++){const n=this.normal.dot(t.vertices[g].pos)-this.w,r=n<-x.EPSILON?2:n>x.EPSILON?1:0;f|=r,p.push(r)}switch(f){case 0:(this.normal.dot(t.plane.normal)>0?s:o).push(t);break;case 1:e.push(t);break;case 2:i.push(t);break;case 3:{const g=[],n=[];for(let r=0;r<t.vertices.length;r++){const a=(r+1)%t.vertices.length,y=p[r],w=p[a],b=t.vertices[r],z=t.vertices[a];if(y!=2&&g.push(b),y!=1&&n.push(y!=2?b.clone():b),(y|w)==3){const T=(this.w-this.normal.dot(b.pos))/this.normal.dot(new d().copy(z.pos).sub(b.pos)),M=b.interpolate(z,T);g.push(M),n.push(M.clone())}}g.length>=3&&e.push(new P(g,t.shared)),n.length>=3&&i.push(new P(n,t.shared));break}}}static fromPoints(t,s,o){const e=new d().copy(s).sub(t).cross(new d().copy(o).sub(t)).normalize();return new x(e.clone(),e.dot(t))}}x.EPSILON=1e-5;class P{constructor(t,s){this.vertices=t,this.shared=s,this.plane=x.fromPoints(t[0].pos,t[1].pos,t[2].pos)}clone(){return new P(this.vertices.map(t=>t.clone()),this.shared)}flip(){this.vertices.reverse().map(t=>t.flip()),this.plane.flip()}}class A{constructor(t,s,o,e){this.pos=new d().copy(t),this.normal=new d().copy(s),this.uv=new d().copy(o),this.uv.z=0,e&&(this.color=new d().copy(e))}clone(){return new A(this.pos,this.normal,this.uv,this.color)}flip(){this.normal.negate()}interpolate(t,s){return new A(this.pos.clone().lerp(t.pos,s),this.normal.clone().lerp(t.normal,s),this.uv.clone().lerp(t.uv,s),this.color&&t.color&&this.color.clone().lerp(t.color,s))}}class c{constructor(){this.polygons=[]}static fromPolygons(t){const s=new c;return s.polygons=t,s}static fromGeometry(t,s){let o=[];const e=t.attributes.position,i=t.attributes.normal,l=t.attributes.uv,m=t.attributes.color,u=t.groups;let h;if(t.index)h=t.index.array;else{h=new Uint16Array(e.array.length/e.itemSize|0);for(let p=0;p<h.length;p++)h[p]=p}const f=h.length/3|0;o=new Array(f);for(let p=0,g=0,n=h.length;p<n;p+=3,g++){const r=new Array(3);for(let a=0;a<3;a++){const y=h[p+a],w=y*3,b=y*2,z=e.array[w],T=e.array[w+1],M=e.array[w+2],F=i.array[w],I=i.array[w+1],R=i.array[w+2],L=l==null?void 0:l.array[b],j=l==null?void 0:l.array[b+1];r[a]=new A(new d(z,T,M),new d(F,I,R),new d(L,j,0),m&&new d(m.array[w],m.array[w+1],m.array[w+2]))}if(s===void 0&&u&&u.length>0)for(const a of u)p>=a.start&&p<a.start+a.count&&(o[g]=new P(r,a.materialIndex));else o[g]=new P(r,s)}return c.fromPolygons(o.filter(p=>!Number.isNaN(p.plane.normal.x)))}static toGeometry(t,s){let o=0;const e=t.polygons;for(const n of e)o+=n.vertices.length-2;const i=new G,l=new B(o*3*3),m=new B(o*3*3),u=new E(o*2*3);let h;const f=[],p=[];for(const n of e){const r=n.vertices,a=r.length;n.shared!==void 0&&(f[n.shared]||(f[n.shared]=[])),a&&r[0].color!==void 0&&(h||(h=new B(o*3*3)));for(let y=3;y<=a;y++)(n.shared===void 0?p:f[n.shared]).push(l.top/3,l.top/3+1,l.top/3+2),l.write(r[0].pos),l.write(r[y-2].pos),l.write(r[y-1].pos),m.write(r[0].normal),m.write(r[y-2].normal),m.write(r[y-1].normal),u&&(u.write(r[0].uv),u.write(r[y-2].uv),u.write(r[y-1].uv)),h&&(h.write(r[0].color),h.write(r[y-2].color),h.write(r[y-1].color))}i.setAttribute("position",new N(l.array,3)),i.setAttribute("normal",new N(m.array,3)),u&&i.setAttribute("uv",new N(u.array,2)),h&&i.setAttribute("color",new N(h.array,3));for(let n=0;n<f.length;n++)f[n]===void 0&&(f[n]=[]);if(f.length){let n=[],r=0;for(let a=0;a<f.length;a++)i.addGroup(r,f[a].length,a),r+=f[a].length,n=n.concat(f[a]);i.addGroup(r,p.length,f.length),n=n.concat(p),i.setIndex(n)}const g=new K().copy(s).invert();return i.applyMatrix4(g),i.computeBoundingSphere(),i.computeBoundingBox(),i}static fromMesh(t,s){const o=c.fromGeometry(t.geometry,s),e=new O,i=new W;i.getNormalMatrix(t.matrix);for(let l=0;l<o.polygons.length;l++){const m=o.polygons[l];for(let u=0;u<m.vertices.length;u++){const h=m.vertices[u];h.pos.copy(e.copy(h.pos.toVector3()).applyMatrix4(t.matrix)),h.normal.copy(e.copy(h.normal.toVector3()).applyMatrix3(i))}}return o}static toMesh(t,s,o){const e=c.toGeometry(t,s),i=new q(e,o);return i.matrix.copy(s),i.matrix.decompose(i.position,i.quaternion,i.scale),i.rotation.setFromQuaternion(i.quaternion),i.updateMatrixWorld(),i.castShadow=i.receiveShadow=!0,i}static union(t,s){const o=c.fromMesh(t),e=c.fromMesh(s);return c.toMesh(o.union(e),t.matrix,t.material)}static subtract(t,s){const o=c.fromMesh(t),e=c.fromMesh(s);return c.toMesh(o.subtract(e),t.matrix,t.material)}static intersect(t,s){const o=c.fromMesh(t),e=c.fromMesh(s);return c.toMesh(o.intersect(e),t.matrix,t.material)}clone(){const t=new c;return t.polygons=this.polygons.map(s=>s.clone()).filter(s=>Number.isFinite(s.plane.w)),t}toPolygons(){return this.polygons}union(t){const s=new v(this.clone().polygons),o=new v(t.clone().polygons);return s.clipTo(o),o.clipTo(s),o.invert(),o.clipTo(s),o.invert(),s.build(o.allPolygons()),c.fromPolygons(s.allPolygons())}subtract(t){const s=new v(this.clone().polygons),o=new v(t.clone().polygons);return s.invert(),s.clipTo(o),o.clipTo(s),o.invert(),o.clipTo(s),o.invert(),s.build(o.allPolygons()),s.invert(),c.fromPolygons(s.allPolygons())}intersect(t){const s=new v(this.clone().polygons),o=new v(t.clone().polygons);return s.invert(),o.clipTo(s),o.invert(),s.clipTo(o),o.clipTo(s),s.build(o.allPolygons()),s.invert(),c.fromPolygons(s.allPolygons())}inverse(){const t=this.clone();for(const s of t.polygons)s.flip();return t}toMesh(t,s){return c.toMesh(this,t,s)}toGeometry(t){return c.toGeometry(this,t)}}class V{constructor(t){this.visible=!0,t.visible&&(this.visible=t.visible)}}class Q extends V{constructor(t){super(t),this.modifiedGeometry=new G,this.timer=0,this.throttling=1e3/15,t.source&&(this.source=t.source),t.target&&(this.target=t.target),this.mode=t.mode||"subtract"}set source(t){this._source=t,this.originalGeometry=this._source.geometry,this.modifiedGeometry.copy(this.originalGeometry),this.source.geometry=this.modifiedGeometry}get source(){return this._source}modify(){if(this._source&&this.target){const t=this._source,s={geometry:this.originalGeometry,matrix:this.source.matrixWorld},o={geometry:this.target.geometry,matrix:this.target.matrixWorld},e=c.fromMesh(s),i=c.fromMesh(o),l=c.toGeometry(e[this.mode](i),t.matrixWorld);this.modifiedGeometry.copy(l)}}render(){this.visible?this.timer||(this.timer=window.setTimeout(()=>{this.modify(),this.timer=0},this.throttling)):this.modifiedGeometry.copy(this.originalGeometry)}apply(){this.originalGeometry.copy(this.modifiedGeometry),this.source.geometry=this.originalGeometry}dispose(){this.source.geometry=this.originalGeometry,this.modifiedGeometry.dispose()}}export{Q as u};
