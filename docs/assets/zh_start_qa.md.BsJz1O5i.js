import{_ as a,c as e,o,a2 as t}from"./chunks/framework.BjUghlZR.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"zh/start/qa.md","filePath":"zh/start/qa.md"}'),c={name:"zh/start/qa.md"},r=t('<h2 id="版本依赖如何稳定安装" tabindex="-1">版本依赖如何稳定安装？ <a class="header-anchor" href="#版本依赖如何稳定安装" aria-label="Permalink to &quot;版本依赖如何稳定安装？&quot;">​</a></h2><ul><li>使用同一大版本，安装<code>0.7</code>版本，所有的相关依赖版本都为<code>^0.7.0</code>。</li><li>版本安装时删除以往的<code>package-lock.json</code>再进行。</li></ul><h2 id="为何会出现重复的依赖引入" tabindex="-1">为何会出现重复的依赖引入？ <a class="header-anchor" href="#为何会出现重复的依赖引入" aria-label="Permalink to &quot;为何会出现重复的依赖引入？&quot;">​</a></h2><p>重复的依赖引入大部分情况出现在有相关<code>xxx-lock.json</code>的锁版本情况，比如<code>npm</code>的<code>package-lock.json</code>，所以在更新依赖的时候可以删除或者绕过版本锁定进行。</p><h2 id="该如何选择配置化开发和组件化开发" tabindex="-1">该如何选择配置化开发和组件化开发？ <a class="header-anchor" href="#该如何选择配置化开发和组件化开发" aria-label="Permalink to &quot;该如何选择配置化开发和组件化开发？&quot;">​</a></h2><p>配置化开发和组件化开发的主要区别在于业务逻辑的封装，配置化开发会将所有的业务逻辑封装在配置中，然而组件化开发可以将业务逻辑进行外放。也就是说，配置化的封装程度会更高，组件化开发的灵活度会更高。</p><p>配置化开发对于需要持久化存储的项目比较友好。如果你的项目业务只是进行一次性的开发，不存在复现的逻辑，组件化开发会更方便。</p><p>当然如果项目的复杂度很高，定制程度也很高，需要自己去平衡配置化与组件化的开发模式。</p>',8),d=[r];function s(n,l,i,_,h,p){return o(),e("div",null,d)}const f=a(c,[["render",s]]);export{u as __pageData,f as default};
